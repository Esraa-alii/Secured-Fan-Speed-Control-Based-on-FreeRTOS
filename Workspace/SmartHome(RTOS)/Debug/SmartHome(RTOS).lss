
SmartHome(RTOS).elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000020d0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000d6  00800060  000020d0  00002164  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000046e  00800136  00800136  0000223a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000223a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000226c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000540  00000000  00000000  000022a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000056cf  00000000  00000000  000027e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013ea  00000000  00000000  00007eb7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003295  00000000  00000000  000092a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ecc  00000000  00000000  0000c538  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000018f1  00000000  00000000  0000d404  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004da2  00000000  00000000  0000ecf5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004e8  00000000  00000000  00013a97  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 6e 04 	jmp	0x8dc	; 0x8dc <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 db 0e 	jmp	0x1db6	; 0x1db6 <__vector_10>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 ed       	ldi	r30, 0xD0	; 208
      68:	f0 e2       	ldi	r31, 0x20	; 32
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a6 33       	cpi	r26, 0x36	; 54
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	a6 e3       	ldi	r26, 0x36	; 54
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 3a       	cpi	r26, 0xA4	; 164
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 66 10 	jmp	0x20cc	; 0x20cc <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
 *  Author: Esraa Ali
 */ 
#include "TaskHandler.h"

int main(){
	TaskRunner();
      92:	0e 94 3f 01 	call	0x27e	; 0x27e <TaskRunner>
      96:	80 e0       	ldi	r24, 0x00	; 0
      98:	90 e0       	ldi	r25, 0x00	; 0
      9a:	08 95       	ret

0000009c <recievePassTask>:
		LCD_voidSendString("welcome");}
		else if (state == WRONG_PASS){
			LCD_voidSendString("Wrong Pass!");
		}
		vTaskDelay(600);
	}
      9c:	cf 93       	push	r28
      9e:	df 93       	push	r29
      a0:	00 d0       	rcall	.+0      	; 0xa2 <recievePassTask+0x6>
      a2:	cd b7       	in	r28, 0x3d	; 61
      a4:	de b7       	in	r29, 0x3e	; 62
      a6:	19 82       	std	Y+1, r1	; 0x01
      a8:	82 e0       	ldi	r24, 0x02	; 2
      aa:	8a 83       	std	Y+2, r24	; 0x02
      ac:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <UART_u8RX>
      b0:	89 83       	std	Y+1, r24	; 0x01
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	44 e6       	ldi	r20, 0x64	; 100
      b6:	50 e0       	ldi	r21, 0x00	; 0
      b8:	be 01       	movw	r22, r28
      ba:	6f 5f       	subi	r22, 0xFF	; 255
      bc:	7f 4f       	sbci	r23, 0xFF	; 255
      be:	80 91 a0 05 	lds	r24, 0x05A0	; 0x8005a0 <passQueue>
      c2:	90 91 a1 05 	lds	r25, 0x05A1	; 0x8005a1 <passQueue+0x1>
      c6:	0e 94 bc 05 	call	0xb78	; 0xb78 <xQueueGenericSend>
      ca:	81 e0       	ldi	r24, 0x01	; 1
      cc:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_voidSendCommand>
      d0:	89 81       	ldd	r24, Y+1	; 0x01
      d2:	81 34       	cpi	r24, 0x41	; 65
      d4:	49 f4       	brne	.+18     	; 0xe8 <recievePassTask+0x4c>
      d6:	60 e0       	ldi	r22, 0x00	; 0
      d8:	70 e0       	ldi	r23, 0x00	; 0
      da:	82 e0       	ldi	r24, 0x02	; 2
      dc:	90 e0       	ldi	r25, 0x00	; 0
      de:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <LED_voidLedOn>
      e2:	81 e0       	ldi	r24, 0x01	; 1
      e4:	8a 83       	std	Y+2, r24	; 0x02
      e6:	03 c0       	rjmp	.+6      	; 0xee <recievePassTask+0x52>
      e8:	0e 94 98 0c 	call	0x1930	; 0x1930 <Buzzer_on>
      ec:	1a 82       	std	Y+2, r1	; 0x02
      ee:	20 e0       	ldi	r18, 0x00	; 0
      f0:	44 e6       	ldi	r20, 0x64	; 100
      f2:	50 e0       	ldi	r21, 0x00	; 0
      f4:	be 01       	movw	r22, r28
      f6:	6e 5f       	subi	r22, 0xFE	; 254
      f8:	7f 4f       	sbci	r23, 0xFF	; 255
      fa:	80 91 9e 05 	lds	r24, 0x059E	; 0x80059e <PassCheckQueue>
      fe:	90 91 9f 05 	lds	r25, 0x059F	; 0x80059f <PassCheckQueue+0x1>
     102:	0e 94 bc 05 	call	0xb78	; 0xb78 <xQueueGenericSend>
     106:	88 e5       	ldi	r24, 0x58	; 88
     108:	92 e0       	ldi	r25, 0x02	; 2
     10a:	0e 94 92 0a 	call	0x1524	; 0x1524 <vTaskDelay>
     10e:	e0 cf       	rjmp	.-64     	; 0xd0 <recievePassTask+0x34>

00000110 <lcdInitTask>:
     110:	60 e0       	ldi	r22, 0x00	; 0
     112:	80 e0       	ldi	r24, 0x00	; 0
     114:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <LCD_voidGotoxy>
     118:	82 e6       	ldi	r24, 0x62	; 98
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <LCD_voidSendString>
     120:	84 ef       	ldi	r24, 0xF4	; 244
     122:	91 e0       	ldi	r25, 0x01	; 1
     124:	0e 94 92 0a 	call	0x1524	; 0x1524 <vTaskDelay>
     128:	f3 cf       	rjmp	.-26     	; 0x110 <lcdInitTask>

0000012a <GetTempTask>:
     12a:	cf 93       	push	r28
     12c:	df 93       	push	r29
     12e:	1f 92       	push	r1
     130:	cd b7       	in	r28, 0x3d	; 61
     132:	de b7       	in	r29, 0x3e	; 62
     134:	19 82       	std	Y+1, r1	; 0x01
     136:	80 e0       	ldi	r24, 0x00	; 0
     138:	0e 94 b2 0d 	call	0x1b64	; 0x1b64 <ADC_u16ReadChannel>
     13c:	96 95       	lsr	r25
     13e:	87 95       	ror	r24
     140:	89 83       	std	Y+1, r24	; 0x01
     142:	20 e0       	ldi	r18, 0x00	; 0
     144:	44 e6       	ldi	r20, 0x64	; 100
     146:	50 e0       	ldi	r21, 0x00	; 0
     148:	be 01       	movw	r22, r28
     14a:	6f 5f       	subi	r22, 0xFF	; 255
     14c:	7f 4f       	sbci	r23, 0xFF	; 255
     14e:	80 91 9c 05 	lds	r24, 0x059C	; 0x80059c <tempQueue>
     152:	90 91 9d 05 	lds	r25, 0x059D	; 0x80059d <tempQueue+0x1>
     156:	0e 94 bc 05 	call	0xb78	; 0xb78 <xQueueGenericSend>
     15a:	88 e5       	ldi	r24, 0x58	; 88
     15c:	92 e0       	ldi	r25, 0x02	; 2
     15e:	0e 94 92 0a 	call	0x1524	; 0x1524 <vTaskDelay>
     162:	e9 cf       	rjmp	.-46     	; 0x136 <GetTempTask+0xc>

00000164 <DisplayTempTask>:
     164:	cf 93       	push	r28
     166:	df 93       	push	r29
     168:	00 d0       	rcall	.+0      	; 0x16a <DisplayTempTask+0x6>
     16a:	cd b7       	in	r28, 0x3d	; 61
     16c:	de b7       	in	r29, 0x3e	; 62
     16e:	19 82       	std	Y+1, r1	; 0x01
     170:	82 e0       	ldi	r24, 0x02	; 2
     172:	8a 83       	std	Y+2, r24	; 0x02
     174:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <__data_end>
     178:	90 91 37 01 	lds	r25, 0x0137	; 0x800137 <__data_end+0x1>
     17c:	0e 94 e5 08 	call	0x11ca	; 0x11ca <vTaskDelete>
     180:	20 e0       	ldi	r18, 0x00	; 0
     182:	44 e6       	ldi	r20, 0x64	; 100
     184:	50 e0       	ldi	r21, 0x00	; 0
     186:	be 01       	movw	r22, r28
     188:	6f 5f       	subi	r22, 0xFF	; 255
     18a:	7f 4f       	sbci	r23, 0xFF	; 255
     18c:	80 91 9c 05 	lds	r24, 0x059C	; 0x80059c <tempQueue>
     190:	90 91 9d 05 	lds	r25, 0x059D	; 0x80059d <tempQueue+0x1>
     194:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xQueueGenericReceive>
     198:	20 e0       	ldi	r18, 0x00	; 0
     19a:	44 e6       	ldi	r20, 0x64	; 100
     19c:	50 e0       	ldi	r21, 0x00	; 0
     19e:	be 01       	movw	r22, r28
     1a0:	6e 5f       	subi	r22, 0xFE	; 254
     1a2:	7f 4f       	sbci	r23, 0xFF	; 255
     1a4:	80 91 9e 05 	lds	r24, 0x059E	; 0x80059e <PassCheckQueue>
     1a8:	90 91 9f 05 	lds	r25, 0x059F	; 0x80059f <PassCheckQueue+0x1>
     1ac:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xQueueGenericReceive>
     1b0:	8a 81       	ldd	r24, Y+2	; 0x02
     1b2:	81 30       	cpi	r24, 0x01	; 1
     1b4:	d9 f4       	brne	.+54     	; 0x1ec <DisplayTempTask+0x88>
     1b6:	60 e0       	ldi	r22, 0x00	; 0
     1b8:	80 e0       	ldi	r24, 0x00	; 0
     1ba:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <LCD_voidGotoxy>
     1be:	82 e7       	ldi	r24, 0x72	; 114
     1c0:	90 e0       	ldi	r25, 0x00	; 0
     1c2:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <LCD_voidSendString>
     1c6:	61 e0       	ldi	r22, 0x01	; 1
     1c8:	80 e0       	ldi	r24, 0x00	; 0
     1ca:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <LCD_voidGotoxy>
     1ce:	81 e8       	ldi	r24, 0x81	; 129
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <LCD_voidSendString>
     1d6:	69 81       	ldd	r22, Y+1	; 0x01
     1d8:	70 e0       	ldi	r23, 0x00	; 0
     1da:	80 e0       	ldi	r24, 0x00	; 0
     1dc:	90 e0       	ldi	r25, 0x00	; 0
     1de:	0e 94 54 0d 	call	0x1aa8	; 0x1aa8 <LCD_voidSendNumber>
     1e2:	89 e8       	ldi	r24, 0x89	; 137
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <LCD_voidSendString>
     1ea:	09 c0       	rjmp	.+18     	; 0x1fe <DisplayTempTask+0x9a>
     1ec:	81 11       	cpse	r24, r1
     1ee:	07 c0       	rjmp	.+14     	; 0x1fe <DisplayTempTask+0x9a>
     1f0:	60 e0       	ldi	r22, 0x00	; 0
     1f2:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <LCD_voidGotoxy>
     1f6:	8b e8       	ldi	r24, 0x8B	; 139
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	0e 94 39 0d 	call	0x1a72	; 0x1a72 <LCD_voidSendString>
     1fe:	88 e5       	ldi	r24, 0x58	; 88
     200:	92 e0       	ldi	r25, 0x02	; 2
     202:	0e 94 92 0a 	call	0x1524	; 0x1524 <vTaskDelay>
     206:	bc cf       	rjmp	.-136    	; 0x180 <DisplayTempTask+0x1c>

00000208 <MotorControlTask>:
     208:	cf 93       	push	r28
     20a:	df 93       	push	r29
     20c:	00 d0       	rcall	.+0      	; 0x20e <MotorControlTask+0x6>
     20e:	cd b7       	in	r28, 0x3d	; 61
     210:	de b7       	in	r29, 0x3e	; 62
     212:	82 e0       	ldi	r24, 0x02	; 2
     214:	89 83       	std	Y+1, r24	; 0x01
     216:	1a 82       	std	Y+2, r1	; 0x02
     218:	20 e0       	ldi	r18, 0x00	; 0
     21a:	44 e6       	ldi	r20, 0x64	; 100
     21c:	50 e0       	ldi	r21, 0x00	; 0
     21e:	be 01       	movw	r22, r28
     220:	6f 5f       	subi	r22, 0xFF	; 255
     222:	7f 4f       	sbci	r23, 0xFF	; 255
     224:	80 91 9e 05 	lds	r24, 0x059E	; 0x80059e <PassCheckQueue>
     228:	90 91 9f 05 	lds	r25, 0x059F	; 0x80059f <PassCheckQueue+0x1>
     22c:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xQueueGenericReceive>
     230:	20 e0       	ldi	r18, 0x00	; 0
     232:	44 e6       	ldi	r20, 0x64	; 100
     234:	50 e0       	ldi	r21, 0x00	; 0
     236:	be 01       	movw	r22, r28
     238:	6e 5f       	subi	r22, 0xFE	; 254
     23a:	7f 4f       	sbci	r23, 0xFF	; 255
     23c:	80 91 9c 05 	lds	r24, 0x059C	; 0x80059c <tempQueue>
     240:	90 91 9d 05 	lds	r25, 0x059D	; 0x80059d <tempQueue+0x1>
     244:	0e 94 4e 06 	call	0xc9c	; 0xc9c <xQueueGenericReceive>
     248:	89 81       	ldd	r24, Y+1	; 0x01
     24a:	81 30       	cpi	r24, 0x01	; 1
     24c:	99 f4       	brne	.+38     	; 0x274 <MotorControlTask+0x6c>
     24e:	8a 81       	ldd	r24, Y+2	; 0x02
     250:	8e 31       	cpi	r24, 0x1E	; 30
     252:	18 f4       	brcc	.+6      	; 0x25a <MotorControlTask+0x52>
     254:	8a e0       	ldi	r24, 0x0A	; 10
     256:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <TIMER0_voidFastPWM>
     25a:	8a 81       	ldd	r24, Y+2	; 0x02
     25c:	8e 51       	subi	r24, 0x1E	; 30
     25e:	8a 30       	cpi	r24, 0x0A	; 10
     260:	18 f4       	brcc	.+6      	; 0x268 <MotorControlTask+0x60>
     262:	82 e3       	ldi	r24, 0x32	; 50
     264:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <TIMER0_voidFastPWM>
     268:	8a 81       	ldd	r24, Y+2	; 0x02
     26a:	82 33       	cpi	r24, 0x32	; 50
     26c:	18 f0       	brcs	.+6      	; 0x274 <MotorControlTask+0x6c>
     26e:	83 e6       	ldi	r24, 0x63	; 99
     270:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <TIMER0_voidFastPWM>
     274:	88 e5       	ldi	r24, 0x58	; 88
     276:	92 e0       	ldi	r25, 0x02	; 2
     278:	0e 94 92 0a 	call	0x1524	; 0x1524 <vTaskDelay>
     27c:	cd cf       	rjmp	.-102    	; 0x218 <MotorControlTask+0x10>

0000027e <TaskRunner>:
	}
}
/*********************************************************************/

/*********************************************************************/
void TaskRunner(void){
     27e:	ef 92       	push	r14
     280:	ff 92       	push	r15
     282:	0f 93       	push	r16
	DIO_voidSetPortDir(DIO_PORTA,0XFF);
     284:	6f ef       	ldi	r22, 0xFF	; 255
     286:	80 e0       	ldi	r24, 0x00	; 0
     288:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <DIO_voidSetPortDir>
	DIO_voidSetPinDir(DIO_PORTA,DIO_PIN0,INPUT);//ADC
     28c:	40 e0       	ldi	r20, 0x00	; 0
     28e:	60 e0       	ldi	r22, 0x00	; 0
     290:	80 e0       	ldi	r24, 0x00	; 0
     292:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <DIO_voidSetPinDir>
	DIO_voidSetPinDir(DIO_PORTD,DIO_PIN0,INPUT);//LED
     296:	40 e0       	ldi	r20, 0x00	; 0
     298:	60 e0       	ldi	r22, 0x00	; 0
     29a:	83 e0       	ldi	r24, 0x03	; 3
     29c:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <DIO_voidSetPinDir>
	DIO_voidSetPinDir(DIO_PORTB,DIO_PIN3,OUTPUT);//MOTOER
     2a0:	41 e0       	ldi	r20, 0x01	; 1
     2a2:	63 e0       	ldi	r22, 0x03	; 3
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <DIO_voidSetPinDir>
	DIO_voidSetPinDir(DIO_PORTC,DIO_PIN0,OUTPUT);//RX
     2aa:	41 e0       	ldi	r20, 0x01	; 1
     2ac:	60 e0       	ldi	r22, 0x00	; 0
     2ae:	82 e0       	ldi	r24, 0x02	; 2
     2b0:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <DIO_voidSetPinDir>
	
	LCD_voidInit();
     2b4:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <LCD_voidInit>
	ADC_voidInit();
     2b8:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <ADC_voidInit>
	UART_voidInit();
     2bc:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <UART_voidInit>
	Buzzer_init();
     2c0:	0e 94 83 0c 	call	0x1906	; 0x1906 <Buzzer_init>
	
	xTaskCreate(lcdInitTask,"LCD Initialization ",80,NULL,PRIORITY_5,&xLCDHandle);
     2c4:	0f 2e       	mov	r0, r31
     2c6:	f6 e3       	ldi	r31, 0x36	; 54
     2c8:	ef 2e       	mov	r14, r31
     2ca:	f1 e0       	ldi	r31, 0x01	; 1
     2cc:	ff 2e       	mov	r15, r31
     2ce:	f0 2d       	mov	r31, r0
     2d0:	05 e0       	ldi	r16, 0x05	; 5
     2d2:	20 e0       	ldi	r18, 0x00	; 0
     2d4:	30 e0       	ldi	r19, 0x00	; 0
     2d6:	40 e5       	ldi	r20, 0x50	; 80
     2d8:	50 e0       	ldi	r21, 0x00	; 0
     2da:	6c ea       	ldi	r22, 0xAC	; 172
     2dc:	70 e0       	ldi	r23, 0x00	; 0
     2de:	88 e8       	ldi	r24, 0x88	; 136
     2e0:	90 e0       	ldi	r25, 0x00	; 0
     2e2:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskCreate>
	xTaskCreate(recievePassTask,"Pass Received and compared with the true pass",80,NULL,PRIORITY_4,NULL);
     2e6:	e1 2c       	mov	r14, r1
     2e8:	f1 2c       	mov	r15, r1
     2ea:	04 e0       	ldi	r16, 0x04	; 4
     2ec:	20 e0       	ldi	r18, 0x00	; 0
     2ee:	30 e0       	ldi	r19, 0x00	; 0
     2f0:	40 e5       	ldi	r20, 0x50	; 80
     2f2:	50 e0       	ldi	r21, 0x00	; 0
     2f4:	60 ec       	ldi	r22, 0xC0	; 192
     2f6:	70 e0       	ldi	r23, 0x00	; 0
     2f8:	8e e4       	ldi	r24, 0x4E	; 78
     2fa:	90 e0       	ldi	r25, 0x00	; 0
     2fc:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskCreate>
	xTaskCreate(GetTempTask,"Measure temp",80,NULL,PRIORITY_3,NULL);
     300:	03 e0       	ldi	r16, 0x03	; 3
     302:	20 e0       	ldi	r18, 0x00	; 0
     304:	30 e0       	ldi	r19, 0x00	; 0
     306:	40 e5       	ldi	r20, 0x50	; 80
     308:	50 e0       	ldi	r21, 0x00	; 0
     30a:	6e ee       	ldi	r22, 0xEE	; 238
     30c:	70 e0       	ldi	r23, 0x00	; 0
     30e:	85 e9       	ldi	r24, 0x95	; 149
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskCreate>
	xTaskCreate(DisplayTempTask,"Display temp value ",80,NULL,PRIORITY_3,NULL);
     316:	20 e0       	ldi	r18, 0x00	; 0
     318:	30 e0       	ldi	r19, 0x00	; 0
     31a:	40 e5       	ldi	r20, 0x50	; 80
     31c:	50 e0       	ldi	r21, 0x00	; 0
     31e:	6b ef       	ldi	r22, 0xFB	; 251
     320:	70 e0       	ldi	r23, 0x00	; 0
     322:	82 eb       	ldi	r24, 0xB2	; 178
     324:	90 e0       	ldi	r25, 0x00	; 0
     326:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskCreate>
	xTaskCreate(MotorControlTask,"Motor control based on temp value",80,NULL,PRIORITY_1,NULL);
     32a:	01 e0       	ldi	r16, 0x01	; 1
     32c:	20 e0       	ldi	r18, 0x00	; 0
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	40 e5       	ldi	r20, 0x50	; 80
     332:	50 e0       	ldi	r21, 0x00	; 0
     334:	6f e0       	ldi	r22, 0x0F	; 15
     336:	71 e0       	ldi	r23, 0x01	; 1
     338:	84 e0       	ldi	r24, 0x04	; 4
     33a:	91 e0       	ldi	r25, 0x01	; 1
     33c:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskCreate>
	
	passQueue = xQueueCreate(SINGLE_VAR,sizeof(u8));
     340:	40 e0       	ldi	r20, 0x00	; 0
     342:	61 e0       	ldi	r22, 0x01	; 1
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	0e 94 92 05 	call	0xb24	; 0xb24 <xQueueGenericCreate>
     34a:	90 93 a1 05 	sts	0x05A1, r25	; 0x8005a1 <passQueue+0x1>
     34e:	80 93 a0 05 	sts	0x05A0, r24	; 0x8005a0 <passQueue>
	tempQueue = xQueueCreate(SINGLE_VAR,sizeof(u8));
     352:	40 e0       	ldi	r20, 0x00	; 0
     354:	61 e0       	ldi	r22, 0x01	; 1
     356:	81 e0       	ldi	r24, 0x01	; 1
     358:	0e 94 92 05 	call	0xb24	; 0xb24 <xQueueGenericCreate>
     35c:	90 93 9d 05 	sts	0x059D, r25	; 0x80059d <tempQueue+0x1>
     360:	80 93 9c 05 	sts	0x059C, r24	; 0x80059c <tempQueue>
	PassCheckQueue = xQueueCreate(SINGLE_VAR,sizeof(u8));
     364:	40 e0       	ldi	r20, 0x00	; 0
     366:	61 e0       	ldi	r22, 0x01	; 1
     368:	81 e0       	ldi	r24, 0x01	; 1
     36a:	0e 94 92 05 	call	0xb24	; 0xb24 <xQueueGenericCreate>
     36e:	90 93 9f 05 	sts	0x059F, r25	; 0x80059f <PassCheckQueue+0x1>
     372:	80 93 9e 05 	sts	0x059E, r24	; 0x80059e <PassCheckQueue>
	
	vTaskStartScheduler();
     376:	0e 94 36 09 	call	0x126c	; 0x126c <vTaskStartScheduler>
}
     37a:	0f 91       	pop	r16
     37c:	ff 90       	pop	r15
     37e:	ef 90       	pop	r14
     380:	08 95       	ret

00000382 <prvHeapInit>:
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     382:	ed e3       	ldi	r30, 0x3D	; 61
     384:	f1 e0       	ldi	r31, 0x01	; 1
     386:	82 e4       	ldi	r24, 0x42	; 66
     388:	91 e0       	ldi	r25, 0x01	; 1
     38a:	91 83       	std	Z+1, r25	; 0x01
     38c:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     38e:	13 82       	std	Z+3, r1	; 0x03
     390:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     392:	e9 e3       	ldi	r30, 0x39	; 57
     394:	f1 e0       	ldi	r31, 0x01	; 1
     396:	87 ee       	ldi	r24, 0xE7	; 231
     398:	93 e0       	ldi	r25, 0x03	; 3
     39a:	93 83       	std	Z+3, r25	; 0x03
     39c:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     39e:	11 82       	std	Z+1, r1	; 0x01
     3a0:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     3a2:	a1 e4       	ldi	r26, 0x41	; 65
     3a4:	b1 e0       	ldi	r27, 0x01	; 1
     3a6:	14 96       	adiw	r26, 0x04	; 4
     3a8:	9c 93       	st	X, r25
     3aa:	8e 93       	st	-X, r24
     3ac:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     3ae:	12 96       	adiw	r26, 0x02	; 2
     3b0:	fc 93       	st	X, r31
     3b2:	ee 93       	st	-X, r30
     3b4:	11 97       	sbiw	r26, 0x01	; 1
     3b6:	08 95       	ret

000003b8 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     3b8:	0f 93       	push	r16
     3ba:	1f 93       	push	r17
     3bc:	cf 93       	push	r28
     3be:	df 93       	push	r29
     3c0:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     3c2:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     3c6:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <xHeapHasBeenInitialised.2079>
     3ca:	81 11       	cpse	r24, r1
     3cc:	05 c0       	rjmp	.+10     	; 0x3d8 <pvPortMalloc+0x20>
		{
			prvHeapInit();
     3ce:	0e 94 c1 01 	call	0x382	; 0x382 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
     3d2:	81 e0       	ldi	r24, 0x01	; 1
     3d4:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <xHeapHasBeenInitialised.2079>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     3d8:	20 97       	sbiw	r28, 0x00	; 0
     3da:	09 f0       	breq	.+2      	; 0x3de <pvPortMalloc+0x26>
		{
			xWantedSize += heapSTRUCT_SIZE;
     3dc:	24 96       	adiw	r28, 0x04	; 4
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     3de:	ce 01       	movw	r24, r28
     3e0:	01 97       	sbiw	r24, 0x01	; 1
     3e2:	86 3e       	cpi	r24, 0xE6	; 230
     3e4:	93 40       	sbci	r25, 0x03	; 3
     3e6:	08 f0       	brcs	.+2      	; 0x3ea <pvPortMalloc+0x32>
     3e8:	56 c0       	rjmp	.+172    	; 0x496 <__EEPROM_REGION_LENGTH__+0x96>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     3ea:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <xStart>
     3ee:	f0 91 3e 01 	lds	r31, 0x013E	; 0x80013e <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     3f2:	ad e3       	ldi	r26, 0x3D	; 61
     3f4:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     3f6:	02 c0       	rjmp	.+4      	; 0x3fc <pvPortMalloc+0x44>
			{
				pxPreviousBlock = pxBlock;
     3f8:	df 01       	movw	r26, r30
				pxBlock = pxBlock->pxNextFreeBlock;
     3fa:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     3fc:	82 81       	ldd	r24, Z+2	; 0x02
     3fe:	93 81       	ldd	r25, Z+3	; 0x03
     400:	8c 17       	cp	r24, r28
     402:	9d 07       	cpc	r25, r29
     404:	20 f4       	brcc	.+8      	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
     406:	80 81       	ld	r24, Z
     408:	91 81       	ldd	r25, Z+1	; 0x01
     40a:	00 97       	sbiw	r24, 0x00	; 0
     40c:	a9 f7       	brne	.-22     	; 0x3f8 <pvPortMalloc+0x40>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	e9 33       	cpi	r30, 0x39	; 57
     412:	f8 07       	cpc	r31, r24
     414:	09 f4       	brne	.+2      	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
     416:	42 c0       	rjmp	.+132    	; 0x49c <__EEPROM_REGION_LENGTH__+0x9c>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     418:	0d 91       	ld	r16, X+
     41a:	1c 91       	ld	r17, X
     41c:	11 97       	sbiw	r26, 0x01	; 1
     41e:	0c 5f       	subi	r16, 0xFC	; 252
     420:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     422:	80 81       	ld	r24, Z
     424:	91 81       	ldd	r25, Z+1	; 0x01
     426:	8d 93       	st	X+, r24
     428:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     42a:	82 81       	ldd	r24, Z+2	; 0x02
     42c:	93 81       	ldd	r25, Z+3	; 0x03
     42e:	8c 1b       	sub	r24, r28
     430:	9d 0b       	sbc	r25, r29
     432:	89 30       	cpi	r24, 0x09	; 9
     434:	91 05       	cpc	r25, r1
     436:	10 f1       	brcs	.+68     	; 0x47c <__EEPROM_REGION_LENGTH__+0x7c>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     438:	af 01       	movw	r20, r30
     43a:	4c 0f       	add	r20, r28
     43c:	5d 1f       	adc	r21, r29

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     43e:	da 01       	movw	r26, r20
     440:	13 96       	adiw	r26, 0x03	; 3
     442:	9c 93       	st	X, r25
     444:	8e 93       	st	-X, r24
     446:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     448:	d3 83       	std	Z+3, r29	; 0x03
     44a:	c2 83       	std	Z+2, r28	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     44c:	12 96       	adiw	r26, 0x02	; 2
     44e:	2d 91       	ld	r18, X+
     450:	3c 91       	ld	r19, X
     452:	13 97       	sbiw	r26, 0x03	; 3
     454:	6d e3       	ldi	r22, 0x3D	; 61
     456:	71 e0       	ldi	r23, 0x01	; 1
     458:	01 c0       	rjmp	.+2      	; 0x45c <__EEPROM_REGION_LENGTH__+0x5c>
     45a:	bd 01       	movw	r22, r26
     45c:	eb 01       	movw	r28, r22
     45e:	a8 81       	ld	r26, Y
     460:	b9 81       	ldd	r27, Y+1	; 0x01
     462:	12 96       	adiw	r26, 0x02	; 2
     464:	8d 91       	ld	r24, X+
     466:	9c 91       	ld	r25, X
     468:	13 97       	sbiw	r26, 0x03	; 3
     46a:	82 17       	cp	r24, r18
     46c:	93 07       	cpc	r25, r19
     46e:	a8 f3       	brcs	.-22     	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
     470:	ea 01       	movw	r28, r20
     472:	b9 83       	std	Y+1, r27	; 0x01
     474:	a8 83       	st	Y, r26
     476:	db 01       	movw	r26, r22
     478:	4d 93       	st	X+, r20
     47a:	5c 93       	st	X, r21
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     47c:	22 81       	ldd	r18, Z+2	; 0x02
     47e:	33 81       	ldd	r19, Z+3	; 0x03
     480:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     484:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     488:	82 1b       	sub	r24, r18
     48a:	93 0b       	sbc	r25, r19
     48c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     490:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     494:	05 c0       	rjmp	.+10     	; 0x4a0 <__EEPROM_REGION_LENGTH__+0xa0>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     496:	00 e0       	ldi	r16, 0x00	; 0
     498:	10 e0       	ldi	r17, 0x00	; 0
     49a:	02 c0       	rjmp	.+4      	; 0x4a0 <__EEPROM_REGION_LENGTH__+0xa0>
     49c:	00 e0       	ldi	r16, 0x00	; 0
     49e:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     4a0:	0e 94 20 0a 	call	0x1440	; 0x1440 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     4a4:	c8 01       	movw	r24, r16
     4a6:	df 91       	pop	r29
     4a8:	cf 91       	pop	r28
     4aa:	1f 91       	pop	r17
     4ac:	0f 91       	pop	r16
     4ae:	08 95       	ret

000004b0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     4b0:	0f 93       	push	r16
     4b2:	1f 93       	push	r17
     4b4:	cf 93       	push	r28
     4b6:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     4b8:	00 97       	sbiw	r24, 0x00	; 0
     4ba:	41 f1       	breq	.+80     	; 0x50c <vPortFree+0x5c>
     4bc:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     4be:	8c 01       	movw	r16, r24
     4c0:	04 50       	subi	r16, 0x04	; 4
     4c2:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     4c4:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     4c8:	f8 01       	movw	r30, r16
     4ca:	42 81       	ldd	r20, Z+2	; 0x02
     4cc:	53 81       	ldd	r21, Z+3	; 0x03
     4ce:	ad e3       	ldi	r26, 0x3D	; 61
     4d0:	b1 e0       	ldi	r27, 0x01	; 1
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <vPortFree+0x26>
     4d4:	df 01       	movw	r26, r30
     4d6:	ed 91       	ld	r30, X+
     4d8:	fc 91       	ld	r31, X
     4da:	11 97       	sbiw	r26, 0x01	; 1
     4dc:	22 81       	ldd	r18, Z+2	; 0x02
     4de:	33 81       	ldd	r19, Z+3	; 0x03
     4e0:	24 17       	cp	r18, r20
     4e2:	35 07       	cpc	r19, r21
     4e4:	b8 f3       	brcs	.-18     	; 0x4d4 <vPortFree+0x24>
     4e6:	24 97       	sbiw	r28, 0x04	; 4
     4e8:	f9 83       	std	Y+1, r31	; 0x01
     4ea:	e8 83       	st	Y, r30
     4ec:	0d 93       	st	X+, r16
     4ee:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     4f0:	8a 81       	ldd	r24, Y+2	; 0x02
     4f2:	9b 81       	ldd	r25, Y+3	; 0x03
     4f4:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     4f8:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     4fc:	82 0f       	add	r24, r18
     4fe:	93 1f       	adc	r25, r19
     500:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     504:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     508:	0e 94 20 0a 	call	0x1440	; 0x1440 <xTaskResumeAll>
	}
}
     50c:	df 91       	pop	r29
     50e:	cf 91       	pop	r28
     510:	1f 91       	pop	r17
     512:	0f 91       	pop	r16
     514:	08 95       	ret

00000516 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     516:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     518:	03 96       	adiw	r24, 0x03	; 3
     51a:	92 83       	std	Z+2, r25	; 0x02
     51c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     51e:	2f ef       	ldi	r18, 0xFF	; 255
     520:	3f ef       	ldi	r19, 0xFF	; 255
     522:	34 83       	std	Z+4, r19	; 0x04
     524:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     526:	96 83       	std	Z+6, r25	; 0x06
     528:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     52a:	90 87       	std	Z+8, r25	; 0x08
     52c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     52e:	10 82       	st	Z, r1
     530:	08 95       	ret

00000532 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     532:	fc 01       	movw	r30, r24
     534:	11 86       	std	Z+9, r1	; 0x09
     536:	10 86       	std	Z+8, r1	; 0x08
     538:	08 95       	ret

0000053a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     53a:	cf 93       	push	r28
     53c:	df 93       	push	r29
     53e:	9c 01       	movw	r18, r24
     540:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     542:	dc 01       	movw	r26, r24
     544:	11 96       	adiw	r26, 0x01	; 1
     546:	cd 91       	ld	r28, X+
     548:	dc 91       	ld	r29, X
     54a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     54c:	d3 83       	std	Z+3, r29	; 0x03
     54e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     550:	8c 81       	ldd	r24, Y+4	; 0x04
     552:	9d 81       	ldd	r25, Y+5	; 0x05
     554:	95 83       	std	Z+5, r25	; 0x05
     556:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     558:	8c 81       	ldd	r24, Y+4	; 0x04
     55a:	9d 81       	ldd	r25, Y+5	; 0x05
     55c:	dc 01       	movw	r26, r24
     55e:	13 96       	adiw	r26, 0x03	; 3
     560:	7c 93       	st	X, r23
     562:	6e 93       	st	-X, r22
     564:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     566:	7d 83       	std	Y+5, r23	; 0x05
     568:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     56a:	31 87       	std	Z+9, r19	; 0x09
     56c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     56e:	f9 01       	movw	r30, r18
     570:	80 81       	ld	r24, Z
     572:	8f 5f       	subi	r24, 0xFF	; 255
     574:	80 83       	st	Z, r24
}
     576:	df 91       	pop	r29
     578:	cf 91       	pop	r28
     57a:	08 95       	ret

0000057c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     57c:	cf 93       	push	r28
     57e:	df 93       	push	r29
     580:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     582:	48 81       	ld	r20, Y
     584:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     586:	4f 3f       	cpi	r20, 0xFF	; 255
     588:	2f ef       	ldi	r18, 0xFF	; 255
     58a:	52 07       	cpc	r21, r18
     58c:	21 f4       	brne	.+8      	; 0x596 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     58e:	fc 01       	movw	r30, r24
     590:	a7 81       	ldd	r26, Z+7	; 0x07
     592:	b0 85       	ldd	r27, Z+8	; 0x08
     594:	0d c0       	rjmp	.+26     	; 0x5b0 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     596:	dc 01       	movw	r26, r24
     598:	13 96       	adiw	r26, 0x03	; 3
     59a:	01 c0       	rjmp	.+2      	; 0x59e <vListInsert+0x22>
     59c:	df 01       	movw	r26, r30
     59e:	12 96       	adiw	r26, 0x02	; 2
     5a0:	ed 91       	ld	r30, X+
     5a2:	fc 91       	ld	r31, X
     5a4:	13 97       	sbiw	r26, 0x03	; 3
     5a6:	20 81       	ld	r18, Z
     5a8:	31 81       	ldd	r19, Z+1	; 0x01
     5aa:	42 17       	cp	r20, r18
     5ac:	53 07       	cpc	r21, r19
     5ae:	b0 f7       	brcc	.-20     	; 0x59c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     5b0:	12 96       	adiw	r26, 0x02	; 2
     5b2:	ed 91       	ld	r30, X+
     5b4:	fc 91       	ld	r31, X
     5b6:	13 97       	sbiw	r26, 0x03	; 3
     5b8:	fb 83       	std	Y+3, r31	; 0x03
     5ba:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     5bc:	d5 83       	std	Z+5, r29	; 0x05
     5be:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     5c0:	bd 83       	std	Y+5, r27	; 0x05
     5c2:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     5c4:	13 96       	adiw	r26, 0x03	; 3
     5c6:	dc 93       	st	X, r29
     5c8:	ce 93       	st	-X, r28
     5ca:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5cc:	99 87       	std	Y+9, r25	; 0x09
     5ce:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     5d0:	fc 01       	movw	r30, r24
     5d2:	20 81       	ld	r18, Z
     5d4:	2f 5f       	subi	r18, 0xFF	; 255
     5d6:	20 83       	st	Z, r18
}
     5d8:	df 91       	pop	r29
     5da:	cf 91       	pop	r28
     5dc:	08 95       	ret

000005de <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     5de:	cf 93       	push	r28
     5e0:	df 93       	push	r29
     5e2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     5e4:	a0 85       	ldd	r26, Z+8	; 0x08
     5e6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     5e8:	c2 81       	ldd	r28, Z+2	; 0x02
     5ea:	d3 81       	ldd	r29, Z+3	; 0x03
     5ec:	84 81       	ldd	r24, Z+4	; 0x04
     5ee:	95 81       	ldd	r25, Z+5	; 0x05
     5f0:	9d 83       	std	Y+5, r25	; 0x05
     5f2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     5f4:	c4 81       	ldd	r28, Z+4	; 0x04
     5f6:	d5 81       	ldd	r29, Z+5	; 0x05
     5f8:	82 81       	ldd	r24, Z+2	; 0x02
     5fa:	93 81       	ldd	r25, Z+3	; 0x03
     5fc:	9b 83       	std	Y+3, r25	; 0x03
     5fe:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     600:	11 96       	adiw	r26, 0x01	; 1
     602:	8d 91       	ld	r24, X+
     604:	9c 91       	ld	r25, X
     606:	12 97       	sbiw	r26, 0x02	; 2
     608:	e8 17       	cp	r30, r24
     60a:	f9 07       	cpc	r31, r25
     60c:	31 f4       	brne	.+12     	; 0x61a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     60e:	84 81       	ldd	r24, Z+4	; 0x04
     610:	95 81       	ldd	r25, Z+5	; 0x05
     612:	12 96       	adiw	r26, 0x02	; 2
     614:	9c 93       	st	X, r25
     616:	8e 93       	st	-X, r24
     618:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     61a:	11 86       	std	Z+9, r1	; 0x09
     61c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     61e:	8c 91       	ld	r24, X
     620:	81 50       	subi	r24, 0x01	; 1
     622:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     624:	df 91       	pop	r29
     626:	cf 91       	pop	r28
     628:	08 95       	ret

0000062a <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     62a:	1b bc       	out	0x2b, r1	; 43
     62c:	89 ef       	ldi	r24, 0xF9	; 249
     62e:	8a bd       	out	0x2a, r24	; 42
     630:	8b e0       	ldi	r24, 0x0B	; 11
     632:	8e bd       	out	0x2e, r24	; 46
     634:	89 b7       	in	r24, 0x39	; 57
     636:	80 61       	ori	r24, 0x10	; 16
     638:	89 bf       	out	0x39, r24	; 57
     63a:	08 95       	ret

0000063c <pxPortInitialiseStack>:
     63c:	31 e1       	ldi	r19, 0x11	; 17
     63e:	fc 01       	movw	r30, r24
     640:	30 83       	st	Z, r19
     642:	31 97       	sbiw	r30, 0x01	; 1
     644:	22 e2       	ldi	r18, 0x22	; 34
     646:	20 83       	st	Z, r18
     648:	31 97       	sbiw	r30, 0x01	; 1
     64a:	a3 e3       	ldi	r26, 0x33	; 51
     64c:	a0 83       	st	Z, r26
     64e:	31 97       	sbiw	r30, 0x01	; 1
     650:	60 83       	st	Z, r22
     652:	31 97       	sbiw	r30, 0x01	; 1
     654:	70 83       	st	Z, r23
     656:	31 97       	sbiw	r30, 0x01	; 1
     658:	10 82       	st	Z, r1
     65a:	31 97       	sbiw	r30, 0x01	; 1
     65c:	60 e8       	ldi	r22, 0x80	; 128
     65e:	60 83       	st	Z, r22
     660:	31 97       	sbiw	r30, 0x01	; 1
     662:	10 82       	st	Z, r1
     664:	31 97       	sbiw	r30, 0x01	; 1
     666:	62 e0       	ldi	r22, 0x02	; 2
     668:	60 83       	st	Z, r22
     66a:	31 97       	sbiw	r30, 0x01	; 1
     66c:	63 e0       	ldi	r22, 0x03	; 3
     66e:	60 83       	st	Z, r22
     670:	31 97       	sbiw	r30, 0x01	; 1
     672:	64 e0       	ldi	r22, 0x04	; 4
     674:	60 83       	st	Z, r22
     676:	31 97       	sbiw	r30, 0x01	; 1
     678:	65 e0       	ldi	r22, 0x05	; 5
     67a:	60 83       	st	Z, r22
     67c:	31 97       	sbiw	r30, 0x01	; 1
     67e:	66 e0       	ldi	r22, 0x06	; 6
     680:	60 83       	st	Z, r22
     682:	31 97       	sbiw	r30, 0x01	; 1
     684:	67 e0       	ldi	r22, 0x07	; 7
     686:	60 83       	st	Z, r22
     688:	31 97       	sbiw	r30, 0x01	; 1
     68a:	68 e0       	ldi	r22, 0x08	; 8
     68c:	60 83       	st	Z, r22
     68e:	31 97       	sbiw	r30, 0x01	; 1
     690:	69 e0       	ldi	r22, 0x09	; 9
     692:	60 83       	st	Z, r22
     694:	31 97       	sbiw	r30, 0x01	; 1
     696:	60 e1       	ldi	r22, 0x10	; 16
     698:	60 83       	st	Z, r22
     69a:	31 97       	sbiw	r30, 0x01	; 1
     69c:	30 83       	st	Z, r19
     69e:	31 97       	sbiw	r30, 0x01	; 1
     6a0:	32 e1       	ldi	r19, 0x12	; 18
     6a2:	30 83       	st	Z, r19
     6a4:	31 97       	sbiw	r30, 0x01	; 1
     6a6:	33 e1       	ldi	r19, 0x13	; 19
     6a8:	30 83       	st	Z, r19
     6aa:	31 97       	sbiw	r30, 0x01	; 1
     6ac:	34 e1       	ldi	r19, 0x14	; 20
     6ae:	30 83       	st	Z, r19
     6b0:	31 97       	sbiw	r30, 0x01	; 1
     6b2:	35 e1       	ldi	r19, 0x15	; 21
     6b4:	30 83       	st	Z, r19
     6b6:	31 97       	sbiw	r30, 0x01	; 1
     6b8:	36 e1       	ldi	r19, 0x16	; 22
     6ba:	30 83       	st	Z, r19
     6bc:	31 97       	sbiw	r30, 0x01	; 1
     6be:	37 e1       	ldi	r19, 0x17	; 23
     6c0:	30 83       	st	Z, r19
     6c2:	31 97       	sbiw	r30, 0x01	; 1
     6c4:	38 e1       	ldi	r19, 0x18	; 24
     6c6:	30 83       	st	Z, r19
     6c8:	31 97       	sbiw	r30, 0x01	; 1
     6ca:	39 e1       	ldi	r19, 0x19	; 25
     6cc:	30 83       	st	Z, r19
     6ce:	31 97       	sbiw	r30, 0x01	; 1
     6d0:	30 e2       	ldi	r19, 0x20	; 32
     6d2:	30 83       	st	Z, r19
     6d4:	31 97       	sbiw	r30, 0x01	; 1
     6d6:	31 e2       	ldi	r19, 0x21	; 33
     6d8:	30 83       	st	Z, r19
     6da:	31 97       	sbiw	r30, 0x01	; 1
     6dc:	20 83       	st	Z, r18
     6de:	31 97       	sbiw	r30, 0x01	; 1
     6e0:	23 e2       	ldi	r18, 0x23	; 35
     6e2:	20 83       	st	Z, r18
     6e4:	31 97       	sbiw	r30, 0x01	; 1
     6e6:	40 83       	st	Z, r20
     6e8:	31 97       	sbiw	r30, 0x01	; 1
     6ea:	50 83       	st	Z, r21
     6ec:	31 97       	sbiw	r30, 0x01	; 1
     6ee:	26 e2       	ldi	r18, 0x26	; 38
     6f0:	20 83       	st	Z, r18
     6f2:	31 97       	sbiw	r30, 0x01	; 1
     6f4:	27 e2       	ldi	r18, 0x27	; 39
     6f6:	20 83       	st	Z, r18
     6f8:	31 97       	sbiw	r30, 0x01	; 1
     6fa:	28 e2       	ldi	r18, 0x28	; 40
     6fc:	20 83       	st	Z, r18
     6fe:	31 97       	sbiw	r30, 0x01	; 1
     700:	29 e2       	ldi	r18, 0x29	; 41
     702:	20 83       	st	Z, r18
     704:	31 97       	sbiw	r30, 0x01	; 1
     706:	20 e3       	ldi	r18, 0x30	; 48
     708:	20 83       	st	Z, r18
     70a:	31 97       	sbiw	r30, 0x01	; 1
     70c:	21 e3       	ldi	r18, 0x31	; 49
     70e:	20 83       	st	Z, r18
     710:	86 97       	sbiw	r24, 0x26	; 38
     712:	08 95       	ret

00000714 <xPortStartScheduler>:
     714:	0e 94 15 03 	call	0x62a	; 0x62a <prvSetupTimerInterrupt>
     718:	a0 91 96 05 	lds	r26, 0x0596	; 0x800596 <pxCurrentTCB>
     71c:	b0 91 97 05 	lds	r27, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
     720:	cd 91       	ld	r28, X+
     722:	cd bf       	out	0x3d, r28	; 61
     724:	dd 91       	ld	r29, X+
     726:	de bf       	out	0x3e, r29	; 62
     728:	ff 91       	pop	r31
     72a:	ef 91       	pop	r30
     72c:	df 91       	pop	r29
     72e:	cf 91       	pop	r28
     730:	bf 91       	pop	r27
     732:	af 91       	pop	r26
     734:	9f 91       	pop	r25
     736:	8f 91       	pop	r24
     738:	7f 91       	pop	r23
     73a:	6f 91       	pop	r22
     73c:	5f 91       	pop	r21
     73e:	4f 91       	pop	r20
     740:	3f 91       	pop	r19
     742:	2f 91       	pop	r18
     744:	1f 91       	pop	r17
     746:	0f 91       	pop	r16
     748:	ff 90       	pop	r15
     74a:	ef 90       	pop	r14
     74c:	df 90       	pop	r13
     74e:	cf 90       	pop	r12
     750:	bf 90       	pop	r11
     752:	af 90       	pop	r10
     754:	9f 90       	pop	r9
     756:	8f 90       	pop	r8
     758:	7f 90       	pop	r7
     75a:	6f 90       	pop	r6
     75c:	5f 90       	pop	r5
     75e:	4f 90       	pop	r4
     760:	3f 90       	pop	r3
     762:	2f 90       	pop	r2
     764:	1f 90       	pop	r1
     766:	0f 90       	pop	r0
     768:	0f be       	out	0x3f, r0	; 63
     76a:	0f 90       	pop	r0
     76c:	08 95       	ret
     76e:	81 e0       	ldi	r24, 0x01	; 1
     770:	08 95       	ret

00000772 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     772:	0f 92       	push	r0
     774:	0f b6       	in	r0, 0x3f	; 63
     776:	f8 94       	cli
     778:	0f 92       	push	r0
     77a:	1f 92       	push	r1
     77c:	11 24       	eor	r1, r1
     77e:	2f 92       	push	r2
     780:	3f 92       	push	r3
     782:	4f 92       	push	r4
     784:	5f 92       	push	r5
     786:	6f 92       	push	r6
     788:	7f 92       	push	r7
     78a:	8f 92       	push	r8
     78c:	9f 92       	push	r9
     78e:	af 92       	push	r10
     790:	bf 92       	push	r11
     792:	cf 92       	push	r12
     794:	df 92       	push	r13
     796:	ef 92       	push	r14
     798:	ff 92       	push	r15
     79a:	0f 93       	push	r16
     79c:	1f 93       	push	r17
     79e:	2f 93       	push	r18
     7a0:	3f 93       	push	r19
     7a2:	4f 93       	push	r20
     7a4:	5f 93       	push	r21
     7a6:	6f 93       	push	r22
     7a8:	7f 93       	push	r23
     7aa:	8f 93       	push	r24
     7ac:	9f 93       	push	r25
     7ae:	af 93       	push	r26
     7b0:	bf 93       	push	r27
     7b2:	cf 93       	push	r28
     7b4:	df 93       	push	r29
     7b6:	ef 93       	push	r30
     7b8:	ff 93       	push	r31
     7ba:	a0 91 96 05 	lds	r26, 0x0596	; 0x800596 <pxCurrentTCB>
     7be:	b0 91 97 05 	lds	r27, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
     7c2:	0d b6       	in	r0, 0x3d	; 61
     7c4:	0d 92       	st	X+, r0
     7c6:	0e b6       	in	r0, 0x3e	; 62
     7c8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     7ca:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     7ce:	a0 91 96 05 	lds	r26, 0x0596	; 0x800596 <pxCurrentTCB>
     7d2:	b0 91 97 05 	lds	r27, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
     7d6:	cd 91       	ld	r28, X+
     7d8:	cd bf       	out	0x3d, r28	; 61
     7da:	dd 91       	ld	r29, X+
     7dc:	de bf       	out	0x3e, r29	; 62
     7de:	ff 91       	pop	r31
     7e0:	ef 91       	pop	r30
     7e2:	df 91       	pop	r29
     7e4:	cf 91       	pop	r28
     7e6:	bf 91       	pop	r27
     7e8:	af 91       	pop	r26
     7ea:	9f 91       	pop	r25
     7ec:	8f 91       	pop	r24
     7ee:	7f 91       	pop	r23
     7f0:	6f 91       	pop	r22
     7f2:	5f 91       	pop	r21
     7f4:	4f 91       	pop	r20
     7f6:	3f 91       	pop	r19
     7f8:	2f 91       	pop	r18
     7fa:	1f 91       	pop	r17
     7fc:	0f 91       	pop	r16
     7fe:	ff 90       	pop	r15
     800:	ef 90       	pop	r14
     802:	df 90       	pop	r13
     804:	cf 90       	pop	r12
     806:	bf 90       	pop	r11
     808:	af 90       	pop	r10
     80a:	9f 90       	pop	r9
     80c:	8f 90       	pop	r8
     80e:	7f 90       	pop	r7
     810:	6f 90       	pop	r6
     812:	5f 90       	pop	r5
     814:	4f 90       	pop	r4
     816:	3f 90       	pop	r3
     818:	2f 90       	pop	r2
     81a:	1f 90       	pop	r1
     81c:	0f 90       	pop	r0
     81e:	0f be       	out	0x3f, r0	; 63
     820:	0f 90       	pop	r0

	asm volatile ( "ret" );
     822:	08 95       	ret

00000824 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     824:	0f 92       	push	r0
     826:	0f b6       	in	r0, 0x3f	; 63
     828:	f8 94       	cli
     82a:	0f 92       	push	r0
     82c:	1f 92       	push	r1
     82e:	11 24       	eor	r1, r1
     830:	2f 92       	push	r2
     832:	3f 92       	push	r3
     834:	4f 92       	push	r4
     836:	5f 92       	push	r5
     838:	6f 92       	push	r6
     83a:	7f 92       	push	r7
     83c:	8f 92       	push	r8
     83e:	9f 92       	push	r9
     840:	af 92       	push	r10
     842:	bf 92       	push	r11
     844:	cf 92       	push	r12
     846:	df 92       	push	r13
     848:	ef 92       	push	r14
     84a:	ff 92       	push	r15
     84c:	0f 93       	push	r16
     84e:	1f 93       	push	r17
     850:	2f 93       	push	r18
     852:	3f 93       	push	r19
     854:	4f 93       	push	r20
     856:	5f 93       	push	r21
     858:	6f 93       	push	r22
     85a:	7f 93       	push	r23
     85c:	8f 93       	push	r24
     85e:	9f 93       	push	r25
     860:	af 93       	push	r26
     862:	bf 93       	push	r27
     864:	cf 93       	push	r28
     866:	df 93       	push	r29
     868:	ef 93       	push	r30
     86a:	ff 93       	push	r31
     86c:	a0 91 96 05 	lds	r26, 0x0596	; 0x800596 <pxCurrentTCB>
     870:	b0 91 97 05 	lds	r27, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
     874:	0d b6       	in	r0, 0x3d	; 61
     876:	0d 92       	st	X+, r0
     878:	0e b6       	in	r0, 0x3e	; 62
     87a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     87c:	0e 94 66 09 	call	0x12cc	; 0x12cc <xTaskIncrementTick>
     880:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     882:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     886:	a0 91 96 05 	lds	r26, 0x0596	; 0x800596 <pxCurrentTCB>
     88a:	b0 91 97 05 	lds	r27, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
     88e:	cd 91       	ld	r28, X+
     890:	cd bf       	out	0x3d, r28	; 61
     892:	dd 91       	ld	r29, X+
     894:	de bf       	out	0x3e, r29	; 62
     896:	ff 91       	pop	r31
     898:	ef 91       	pop	r30
     89a:	df 91       	pop	r29
     89c:	cf 91       	pop	r28
     89e:	bf 91       	pop	r27
     8a0:	af 91       	pop	r26
     8a2:	9f 91       	pop	r25
     8a4:	8f 91       	pop	r24
     8a6:	7f 91       	pop	r23
     8a8:	6f 91       	pop	r22
     8aa:	5f 91       	pop	r21
     8ac:	4f 91       	pop	r20
     8ae:	3f 91       	pop	r19
     8b0:	2f 91       	pop	r18
     8b2:	1f 91       	pop	r17
     8b4:	0f 91       	pop	r16
     8b6:	ff 90       	pop	r15
     8b8:	ef 90       	pop	r14
     8ba:	df 90       	pop	r13
     8bc:	cf 90       	pop	r12
     8be:	bf 90       	pop	r11
     8c0:	af 90       	pop	r10
     8c2:	9f 90       	pop	r9
     8c4:	8f 90       	pop	r8
     8c6:	7f 90       	pop	r7
     8c8:	6f 90       	pop	r6
     8ca:	5f 90       	pop	r5
     8cc:	4f 90       	pop	r4
     8ce:	3f 90       	pop	r3
     8d0:	2f 90       	pop	r2
     8d2:	1f 90       	pop	r1
     8d4:	0f 90       	pop	r0
     8d6:	0f be       	out	0x3f, r0	; 63
     8d8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     8da:	08 95       	ret

000008dc <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     8dc:	0e 94 12 04 	call	0x824	; 0x824 <vPortYieldFromTick>
		asm volatile ( "reti" );
     8e0:	18 95       	reti

000008e2 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     8e2:	0f b6       	in	r0, 0x3f	; 63
     8e4:	f8 94       	cli
     8e6:	0f 92       	push	r0
     8e8:	fc 01       	movw	r30, r24
     8ea:	82 8d       	ldd	r24, Z+26	; 0x1a
     8ec:	81 11       	cpse	r24, r1
     8ee:	02 c0       	rjmp	.+4      	; 0x8f4 <prvIsQueueEmpty+0x12>
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	01 c0       	rjmp	.+2      	; 0x8f6 <prvIsQueueEmpty+0x14>
     8f4:	80 e0       	ldi	r24, 0x00	; 0
     8f6:	0f 90       	pop	r0
     8f8:	0f be       	out	0x3f, r0	; 63
     8fa:	08 95       	ret

000008fc <prvIsQueueFull>:
     8fc:	0f b6       	in	r0, 0x3f	; 63
     8fe:	f8 94       	cli
     900:	0f 92       	push	r0
     902:	fc 01       	movw	r30, r24
     904:	22 8d       	ldd	r18, Z+26	; 0x1a
     906:	83 8d       	ldd	r24, Z+27	; 0x1b
     908:	28 13       	cpse	r18, r24
     90a:	02 c0       	rjmp	.+4      	; 0x910 <prvIsQueueFull+0x14>
     90c:	81 e0       	ldi	r24, 0x01	; 1
     90e:	01 c0       	rjmp	.+2      	; 0x912 <prvIsQueueFull+0x16>
     910:	80 e0       	ldi	r24, 0x00	; 0
     912:	0f 90       	pop	r0
     914:	0f be       	out	0x3f, r0	; 63
     916:	08 95       	ret

00000918 <prvCopyDataToQueue>:
     918:	0f 93       	push	r16
     91a:	1f 93       	push	r17
     91c:	cf 93       	push	r28
     91e:	df 93       	push	r29
     920:	ec 01       	movw	r28, r24
     922:	04 2f       	mov	r16, r20
     924:	1a 8d       	ldd	r17, Y+26	; 0x1a
     926:	4c 8d       	ldd	r20, Y+28	; 0x1c
     928:	41 11       	cpse	r20, r1
     92a:	0c c0       	rjmp	.+24     	; 0x944 <prvCopyDataToQueue+0x2c>
     92c:	88 81       	ld	r24, Y
     92e:	99 81       	ldd	r25, Y+1	; 0x01
     930:	89 2b       	or	r24, r25
     932:	09 f0       	breq	.+2      	; 0x936 <prvCopyDataToQueue+0x1e>
     934:	42 c0       	rjmp	.+132    	; 0x9ba <prvCopyDataToQueue+0xa2>
     936:	8a 81       	ldd	r24, Y+2	; 0x02
     938:	9b 81       	ldd	r25, Y+3	; 0x03
     93a:	0e 94 31 0c 	call	0x1862	; 0x1862 <xTaskPriorityDisinherit>
     93e:	1b 82       	std	Y+3, r1	; 0x03
     940:	1a 82       	std	Y+2, r1	; 0x02
     942:	42 c0       	rjmp	.+132    	; 0x9c8 <prvCopyDataToQueue+0xb0>
     944:	01 11       	cpse	r16, r1
     946:	17 c0       	rjmp	.+46     	; 0x976 <prvCopyDataToQueue+0x5e>
     948:	50 e0       	ldi	r21, 0x00	; 0
     94a:	8c 81       	ldd	r24, Y+4	; 0x04
     94c:	9d 81       	ldd	r25, Y+5	; 0x05
     94e:	0e 94 5d 10 	call	0x20ba	; 0x20ba <memcpy>
     952:	2c 8d       	ldd	r18, Y+28	; 0x1c
     954:	8c 81       	ldd	r24, Y+4	; 0x04
     956:	9d 81       	ldd	r25, Y+5	; 0x05
     958:	82 0f       	add	r24, r18
     95a:	91 1d       	adc	r25, r1
     95c:	9d 83       	std	Y+5, r25	; 0x05
     95e:	8c 83       	std	Y+4, r24	; 0x04
     960:	2a 81       	ldd	r18, Y+2	; 0x02
     962:	3b 81       	ldd	r19, Y+3	; 0x03
     964:	82 17       	cp	r24, r18
     966:	93 07       	cpc	r25, r19
     968:	50 f1       	brcs	.+84     	; 0x9be <prvCopyDataToQueue+0xa6>
     96a:	88 81       	ld	r24, Y
     96c:	99 81       	ldd	r25, Y+1	; 0x01
     96e:	9d 83       	std	Y+5, r25	; 0x05
     970:	8c 83       	std	Y+4, r24	; 0x04
     972:	80 e0       	ldi	r24, 0x00	; 0
     974:	29 c0       	rjmp	.+82     	; 0x9c8 <prvCopyDataToQueue+0xb0>
     976:	50 e0       	ldi	r21, 0x00	; 0
     978:	8e 81       	ldd	r24, Y+6	; 0x06
     97a:	9f 81       	ldd	r25, Y+7	; 0x07
     97c:	0e 94 5d 10 	call	0x20ba	; 0x20ba <memcpy>
     980:	8c 8d       	ldd	r24, Y+28	; 0x1c
     982:	90 e0       	ldi	r25, 0x00	; 0
     984:	91 95       	neg	r25
     986:	81 95       	neg	r24
     988:	91 09       	sbc	r25, r1
     98a:	2e 81       	ldd	r18, Y+6	; 0x06
     98c:	3f 81       	ldd	r19, Y+7	; 0x07
     98e:	28 0f       	add	r18, r24
     990:	39 1f       	adc	r19, r25
     992:	3f 83       	std	Y+7, r19	; 0x07
     994:	2e 83       	std	Y+6, r18	; 0x06
     996:	48 81       	ld	r20, Y
     998:	59 81       	ldd	r21, Y+1	; 0x01
     99a:	24 17       	cp	r18, r20
     99c:	35 07       	cpc	r19, r21
     99e:	30 f4       	brcc	.+12     	; 0x9ac <prvCopyDataToQueue+0x94>
     9a0:	2a 81       	ldd	r18, Y+2	; 0x02
     9a2:	3b 81       	ldd	r19, Y+3	; 0x03
     9a4:	82 0f       	add	r24, r18
     9a6:	93 1f       	adc	r25, r19
     9a8:	9f 83       	std	Y+7, r25	; 0x07
     9aa:	8e 83       	std	Y+6, r24	; 0x06
     9ac:	02 30       	cpi	r16, 0x02	; 2
     9ae:	49 f4       	brne	.+18     	; 0x9c2 <prvCopyDataToQueue+0xaa>
     9b0:	11 23       	and	r17, r17
     9b2:	49 f0       	breq	.+18     	; 0x9c6 <prvCopyDataToQueue+0xae>
     9b4:	11 50       	subi	r17, 0x01	; 1
     9b6:	80 e0       	ldi	r24, 0x00	; 0
     9b8:	07 c0       	rjmp	.+14     	; 0x9c8 <prvCopyDataToQueue+0xb0>
     9ba:	80 e0       	ldi	r24, 0x00	; 0
     9bc:	05 c0       	rjmp	.+10     	; 0x9c8 <prvCopyDataToQueue+0xb0>
     9be:	80 e0       	ldi	r24, 0x00	; 0
     9c0:	03 c0       	rjmp	.+6      	; 0x9c8 <prvCopyDataToQueue+0xb0>
     9c2:	80 e0       	ldi	r24, 0x00	; 0
     9c4:	01 c0       	rjmp	.+2      	; 0x9c8 <prvCopyDataToQueue+0xb0>
     9c6:	80 e0       	ldi	r24, 0x00	; 0
     9c8:	1f 5f       	subi	r17, 0xFF	; 255
     9ca:	1a 8f       	std	Y+26, r17	; 0x1a
     9cc:	df 91       	pop	r29
     9ce:	cf 91       	pop	r28
     9d0:	1f 91       	pop	r17
     9d2:	0f 91       	pop	r16
     9d4:	08 95       	ret

000009d6 <prvCopyDataFromQueue>:
     9d6:	fc 01       	movw	r30, r24
     9d8:	44 8d       	ldd	r20, Z+28	; 0x1c
     9da:	44 23       	and	r20, r20
     9dc:	a9 f0       	breq	.+42     	; 0xa08 <prvCopyDataFromQueue+0x32>
     9de:	50 e0       	ldi	r21, 0x00	; 0
     9e0:	26 81       	ldd	r18, Z+6	; 0x06
     9e2:	37 81       	ldd	r19, Z+7	; 0x07
     9e4:	24 0f       	add	r18, r20
     9e6:	35 1f       	adc	r19, r21
     9e8:	37 83       	std	Z+7, r19	; 0x07
     9ea:	26 83       	std	Z+6, r18	; 0x06
     9ec:	82 81       	ldd	r24, Z+2	; 0x02
     9ee:	93 81       	ldd	r25, Z+3	; 0x03
     9f0:	28 17       	cp	r18, r24
     9f2:	39 07       	cpc	r19, r25
     9f4:	20 f0       	brcs	.+8      	; 0x9fe <prvCopyDataFromQueue+0x28>
     9f6:	80 81       	ld	r24, Z
     9f8:	91 81       	ldd	r25, Z+1	; 0x01
     9fa:	97 83       	std	Z+7, r25	; 0x07
     9fc:	86 83       	std	Z+6, r24	; 0x06
     9fe:	cb 01       	movw	r24, r22
     a00:	66 81       	ldd	r22, Z+6	; 0x06
     a02:	77 81       	ldd	r23, Z+7	; 0x07
     a04:	0e 94 5d 10 	call	0x20ba	; 0x20ba <memcpy>
     a08:	08 95       	ret

00000a0a <prvUnlockQueue>:
     a0a:	1f 93       	push	r17
     a0c:	cf 93       	push	r28
     a0e:	df 93       	push	r29
     a10:	ec 01       	movw	r28, r24
     a12:	0f b6       	in	r0, 0x3f	; 63
     a14:	f8 94       	cli
     a16:	0f 92       	push	r0
     a18:	1e 8d       	ldd	r17, Y+30	; 0x1e
     a1a:	0b c0       	rjmp	.+22     	; 0xa32 <prvUnlockQueue+0x28>
     a1c:	89 89       	ldd	r24, Y+17	; 0x11
     a1e:	88 23       	and	r24, r24
     a20:	51 f0       	breq	.+20     	; 0xa36 <prvUnlockQueue+0x2c>
     a22:	ce 01       	movw	r24, r28
     a24:	41 96       	adiw	r24, 0x11	; 17
     a26:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskRemoveFromEventList>
     a2a:	81 11       	cpse	r24, r1
     a2c:	0e 94 cb 0b 	call	0x1796	; 0x1796 <vTaskMissedYield>
     a30:	11 50       	subi	r17, 0x01	; 1
     a32:	11 16       	cp	r1, r17
     a34:	9c f3       	brlt	.-26     	; 0xa1c <prvUnlockQueue+0x12>
     a36:	8f ef       	ldi	r24, 0xFF	; 255
     a38:	8e 8f       	std	Y+30, r24	; 0x1e
     a3a:	0f 90       	pop	r0
     a3c:	0f be       	out	0x3f, r0	; 63
     a3e:	0f b6       	in	r0, 0x3f	; 63
     a40:	f8 94       	cli
     a42:	0f 92       	push	r0
     a44:	1d 8d       	ldd	r17, Y+29	; 0x1d
     a46:	0b c0       	rjmp	.+22     	; 0xa5e <prvUnlockQueue+0x54>
     a48:	88 85       	ldd	r24, Y+8	; 0x08
     a4a:	88 23       	and	r24, r24
     a4c:	51 f0       	breq	.+20     	; 0xa62 <prvUnlockQueue+0x58>
     a4e:	ce 01       	movw	r24, r28
     a50:	08 96       	adiw	r24, 0x08	; 8
     a52:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskRemoveFromEventList>
     a56:	81 11       	cpse	r24, r1
     a58:	0e 94 cb 0b 	call	0x1796	; 0x1796 <vTaskMissedYield>
     a5c:	11 50       	subi	r17, 0x01	; 1
     a5e:	11 16       	cp	r1, r17
     a60:	9c f3       	brlt	.-26     	; 0xa48 <prvUnlockQueue+0x3e>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	8d 8f       	std	Y+29, r24	; 0x1d
     a66:	0f 90       	pop	r0
     a68:	0f be       	out	0x3f, r0	; 63
     a6a:	df 91       	pop	r29
     a6c:	cf 91       	pop	r28
     a6e:	1f 91       	pop	r17
     a70:	08 95       	ret

00000a72 <xQueueGenericReset>:
     a72:	cf 93       	push	r28
     a74:	df 93       	push	r29
     a76:	ec 01       	movw	r28, r24
     a78:	0f b6       	in	r0, 0x3f	; 63
     a7a:	f8 94       	cli
     a7c:	0f 92       	push	r0
     a7e:	e8 81       	ld	r30, Y
     a80:	f9 81       	ldd	r31, Y+1	; 0x01
     a82:	8b 8d       	ldd	r24, Y+27	; 0x1b
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	2c 8d       	ldd	r18, Y+28	; 0x1c
     a88:	30 e0       	ldi	r19, 0x00	; 0
     a8a:	82 9f       	mul	r24, r18
     a8c:	a0 01       	movw	r20, r0
     a8e:	83 9f       	mul	r24, r19
     a90:	50 0d       	add	r21, r0
     a92:	92 9f       	mul	r25, r18
     a94:	50 0d       	add	r21, r0
     a96:	11 24       	eor	r1, r1
     a98:	4e 0f       	add	r20, r30
     a9a:	5f 1f       	adc	r21, r31
     a9c:	5b 83       	std	Y+3, r21	; 0x03
     a9e:	4a 83       	std	Y+2, r20	; 0x02
     aa0:	1a 8e       	std	Y+26, r1	; 0x1a
     aa2:	fd 83       	std	Y+5, r31	; 0x05
     aa4:	ec 83       	std	Y+4, r30	; 0x04
     aa6:	01 97       	sbiw	r24, 0x01	; 1
     aa8:	28 9f       	mul	r18, r24
     aaa:	a0 01       	movw	r20, r0
     aac:	29 9f       	mul	r18, r25
     aae:	50 0d       	add	r21, r0
     ab0:	38 9f       	mul	r19, r24
     ab2:	50 0d       	add	r21, r0
     ab4:	11 24       	eor	r1, r1
     ab6:	cf 01       	movw	r24, r30
     ab8:	84 0f       	add	r24, r20
     aba:	95 1f       	adc	r25, r21
     abc:	9f 83       	std	Y+7, r25	; 0x07
     abe:	8e 83       	std	Y+6, r24	; 0x06
     ac0:	8f ef       	ldi	r24, 0xFF	; 255
     ac2:	8d 8f       	std	Y+29, r24	; 0x1d
     ac4:	8e 8f       	std	Y+30, r24	; 0x1e
     ac6:	61 11       	cpse	r22, r1
     ac8:	0c c0       	rjmp	.+24     	; 0xae2 <xQueueGenericReset+0x70>
     aca:	88 85       	ldd	r24, Y+8	; 0x08
     acc:	88 23       	and	r24, r24
     ace:	89 f0       	breq	.+34     	; 0xaf2 <xQueueGenericReset+0x80>
     ad0:	ce 01       	movw	r24, r28
     ad2:	08 96       	adiw	r24, 0x08	; 8
     ad4:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskRemoveFromEventList>
     ad8:	88 23       	and	r24, r24
     ada:	59 f0       	breq	.+22     	; 0xaf2 <xQueueGenericReset+0x80>
     adc:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
     ae0:	08 c0       	rjmp	.+16     	; 0xaf2 <xQueueGenericReset+0x80>
     ae2:	ce 01       	movw	r24, r28
     ae4:	08 96       	adiw	r24, 0x08	; 8
     ae6:	0e 94 8b 02 	call	0x516	; 0x516 <vListInitialise>
     aea:	ce 01       	movw	r24, r28
     aec:	41 96       	adiw	r24, 0x11	; 17
     aee:	0e 94 8b 02 	call	0x516	; 0x516 <vListInitialise>
     af2:	0f 90       	pop	r0
     af4:	0f be       	out	0x3f, r0	; 63
     af6:	81 e0       	ldi	r24, 0x01	; 1
     af8:	df 91       	pop	r29
     afa:	cf 91       	pop	r28
     afc:	08 95       	ret

00000afe <prvInitialiseNewQueue>:
     afe:	0f 93       	push	r16
     b00:	1f 93       	push	r17
     b02:	f8 01       	movw	r30, r16
     b04:	61 11       	cpse	r22, r1
     b06:	03 c0       	rjmp	.+6      	; 0xb0e <prvInitialiseNewQueue+0x10>
     b08:	11 83       	std	Z+1, r17	; 0x01
     b0a:	00 83       	st	Z, r16
     b0c:	02 c0       	rjmp	.+4      	; 0xb12 <prvInitialiseNewQueue+0x14>
     b0e:	51 83       	std	Z+1, r21	; 0x01
     b10:	40 83       	st	Z, r20
     b12:	83 8f       	std	Z+27, r24	; 0x1b
     b14:	64 8f       	std	Z+28, r22	; 0x1c
     b16:	61 e0       	ldi	r22, 0x01	; 1
     b18:	cf 01       	movw	r24, r30
     b1a:	0e 94 39 05 	call	0xa72	; 0xa72 <xQueueGenericReset>
     b1e:	1f 91       	pop	r17
     b20:	0f 91       	pop	r16
     b22:	08 95       	ret

00000b24 <xQueueGenericCreate>:
     b24:	df 92       	push	r13
     b26:	ef 92       	push	r14
     b28:	ff 92       	push	r15
     b2a:	0f 93       	push	r16
     b2c:	1f 93       	push	r17
     b2e:	cf 93       	push	r28
     b30:	df 93       	push	r29
     b32:	e8 2e       	mov	r14, r24
     b34:	f6 2e       	mov	r15, r22
     b36:	d4 2e       	mov	r13, r20
     b38:	66 23       	and	r22, r22
     b3a:	21 f0       	breq	.+8      	; 0xb44 <xQueueGenericCreate+0x20>
     b3c:	86 9f       	mul	r24, r22
     b3e:	c0 01       	movw	r24, r0
     b40:	11 24       	eor	r1, r1
     b42:	02 c0       	rjmp	.+4      	; 0xb48 <xQueueGenericCreate+0x24>
     b44:	80 e0       	ldi	r24, 0x00	; 0
     b46:	90 e0       	ldi	r25, 0x00	; 0
     b48:	4f 96       	adiw	r24, 0x1f	; 31
     b4a:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pvPortMalloc>
     b4e:	ec 01       	movw	r28, r24
     b50:	00 97       	sbiw	r24, 0x00	; 0
     b52:	49 f0       	breq	.+18     	; 0xb66 <xQueueGenericCreate+0x42>
     b54:	8c 01       	movw	r16, r24
     b56:	2d 2d       	mov	r18, r13
     b58:	ac 01       	movw	r20, r24
     b5a:	41 5e       	subi	r20, 0xE1	; 225
     b5c:	5f 4f       	sbci	r21, 0xFF	; 255
     b5e:	6f 2d       	mov	r22, r15
     b60:	8e 2d       	mov	r24, r14
     b62:	0e 94 7f 05 	call	0xafe	; 0xafe <prvInitialiseNewQueue>
     b66:	ce 01       	movw	r24, r28
     b68:	df 91       	pop	r29
     b6a:	cf 91       	pop	r28
     b6c:	1f 91       	pop	r17
     b6e:	0f 91       	pop	r16
     b70:	ff 90       	pop	r15
     b72:	ef 90       	pop	r14
     b74:	df 90       	pop	r13
     b76:	08 95       	ret

00000b78 <xQueueGenericSend>:
     b78:	cf 92       	push	r12
     b7a:	df 92       	push	r13
     b7c:	ef 92       	push	r14
     b7e:	ff 92       	push	r15
     b80:	0f 93       	push	r16
     b82:	1f 93       	push	r17
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
     b88:	00 d0       	rcall	.+0      	; 0xb8a <xQueueGenericSend+0x12>
     b8a:	00 d0       	rcall	.+0      	; 0xb8c <xQueueGenericSend+0x14>
     b8c:	1f 92       	push	r1
     b8e:	cd b7       	in	r28, 0x3d	; 61
     b90:	de b7       	in	r29, 0x3e	; 62
     b92:	8c 01       	movw	r16, r24
     b94:	7b 01       	movw	r14, r22
     b96:	5d 83       	std	Y+5, r21	; 0x05
     b98:	4c 83       	std	Y+4, r20	; 0x04
     b9a:	c2 2e       	mov	r12, r18
     b9c:	d1 2c       	mov	r13, r1
     b9e:	0f b6       	in	r0, 0x3f	; 63
     ba0:	f8 94       	cli
     ba2:	0f 92       	push	r0
     ba4:	f8 01       	movw	r30, r16
     ba6:	92 8d       	ldd	r25, Z+26	; 0x1a
     ba8:	83 8d       	ldd	r24, Z+27	; 0x1b
     baa:	98 17       	cp	r25, r24
     bac:	18 f0       	brcs	.+6      	; 0xbb4 <xQueueGenericSend+0x3c>
     bae:	f2 e0       	ldi	r31, 0x02	; 2
     bb0:	cf 12       	cpse	r12, r31
     bb2:	19 c0       	rjmp	.+50     	; 0xbe6 <xQueueGenericSend+0x6e>
     bb4:	4c 2d       	mov	r20, r12
     bb6:	b7 01       	movw	r22, r14
     bb8:	c8 01       	movw	r24, r16
     bba:	0e 94 8c 04 	call	0x918	; 0x918 <prvCopyDataToQueue>
     bbe:	f8 01       	movw	r30, r16
     bc0:	91 89       	ldd	r25, Z+17	; 0x11
     bc2:	99 23       	and	r25, r25
     bc4:	49 f0       	breq	.+18     	; 0xbd8 <xQueueGenericSend+0x60>
     bc6:	c8 01       	movw	r24, r16
     bc8:	41 96       	adiw	r24, 0x11	; 17
     bca:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskRemoveFromEventList>
     bce:	88 23       	and	r24, r24
     bd0:	31 f0       	breq	.+12     	; 0xbde <xQueueGenericSend+0x66>
     bd2:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
     bd6:	03 c0       	rjmp	.+6      	; 0xbde <xQueueGenericSend+0x66>
     bd8:	81 11       	cpse	r24, r1
     bda:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
     bde:	0f 90       	pop	r0
     be0:	0f be       	out	0x3f, r0	; 63
     be2:	81 e0       	ldi	r24, 0x01	; 1
     be4:	4d c0       	rjmp	.+154    	; 0xc80 <xQueueGenericSend+0x108>
     be6:	8c 81       	ldd	r24, Y+4	; 0x04
     be8:	9d 81       	ldd	r25, Y+5	; 0x05
     bea:	89 2b       	or	r24, r25
     bec:	21 f4       	brne	.+8      	; 0xbf6 <xQueueGenericSend+0x7e>
     bee:	0f 90       	pop	r0
     bf0:	0f be       	out	0x3f, r0	; 63
     bf2:	80 e0       	ldi	r24, 0x00	; 0
     bf4:	45 c0       	rjmp	.+138    	; 0xc80 <xQueueGenericSend+0x108>
     bf6:	d1 10       	cpse	r13, r1
     bf8:	06 c0       	rjmp	.+12     	; 0xc06 <xQueueGenericSend+0x8e>
     bfa:	ce 01       	movw	r24, r28
     bfc:	01 96       	adiw	r24, 0x01	; 1
     bfe:	0e 94 87 0b 	call	0x170e	; 0x170e <vTaskSetTimeOutState>
     c02:	dd 24       	eor	r13, r13
     c04:	d3 94       	inc	r13
     c06:	0f 90       	pop	r0
     c08:	0f be       	out	0x3f, r0	; 63
     c0a:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vTaskSuspendAll>
     c0e:	0f b6       	in	r0, 0x3f	; 63
     c10:	f8 94       	cli
     c12:	0f 92       	push	r0
     c14:	f8 01       	movw	r30, r16
     c16:	85 8d       	ldd	r24, Z+29	; 0x1d
     c18:	8f 3f       	cpi	r24, 0xFF	; 255
     c1a:	09 f4       	brne	.+2      	; 0xc1e <xQueueGenericSend+0xa6>
     c1c:	15 8e       	std	Z+29, r1	; 0x1d
     c1e:	f8 01       	movw	r30, r16
     c20:	86 8d       	ldd	r24, Z+30	; 0x1e
     c22:	8f 3f       	cpi	r24, 0xFF	; 255
     c24:	09 f4       	brne	.+2      	; 0xc28 <xQueueGenericSend+0xb0>
     c26:	16 8e       	std	Z+30, r1	; 0x1e
     c28:	0f 90       	pop	r0
     c2a:	0f be       	out	0x3f, r0	; 63
     c2c:	be 01       	movw	r22, r28
     c2e:	6c 5f       	subi	r22, 0xFC	; 252
     c30:	7f 4f       	sbci	r23, 0xFF	; 255
     c32:	ce 01       	movw	r24, r28
     c34:	01 96       	adiw	r24, 0x01	; 1
     c36:	0e 94 92 0b 	call	0x1724	; 0x1724 <xTaskCheckForTimeOut>
     c3a:	81 11       	cpse	r24, r1
     c3c:	1b c0       	rjmp	.+54     	; 0xc74 <xQueueGenericSend+0xfc>
     c3e:	c8 01       	movw	r24, r16
     c40:	0e 94 7e 04 	call	0x8fc	; 0x8fc <prvIsQueueFull>
     c44:	88 23       	and	r24, r24
     c46:	81 f0       	breq	.+32     	; 0xc68 <xQueueGenericSend+0xf0>
     c48:	6c 81       	ldd	r22, Y+4	; 0x04
     c4a:	7d 81       	ldd	r23, Y+5	; 0x05
     c4c:	c8 01       	movw	r24, r16
     c4e:	08 96       	adiw	r24, 0x08	; 8
     c50:	0e 94 2d 0b 	call	0x165a	; 0x165a <vTaskPlaceOnEventList>
     c54:	c8 01       	movw	r24, r16
     c56:	0e 94 05 05 	call	0xa0a	; 0xa0a <prvUnlockQueue>
     c5a:	0e 94 20 0a 	call	0x1440	; 0x1440 <xTaskResumeAll>
     c5e:	81 11       	cpse	r24, r1
     c60:	9e cf       	rjmp	.-196    	; 0xb9e <xQueueGenericSend+0x26>
     c62:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
     c66:	9b cf       	rjmp	.-202    	; 0xb9e <xQueueGenericSend+0x26>
     c68:	c8 01       	movw	r24, r16
     c6a:	0e 94 05 05 	call	0xa0a	; 0xa0a <prvUnlockQueue>
     c6e:	0e 94 20 0a 	call	0x1440	; 0x1440 <xTaskResumeAll>
     c72:	95 cf       	rjmp	.-214    	; 0xb9e <xQueueGenericSend+0x26>
     c74:	c8 01       	movw	r24, r16
     c76:	0e 94 05 05 	call	0xa0a	; 0xa0a <prvUnlockQueue>
     c7a:	0e 94 20 0a 	call	0x1440	; 0x1440 <xTaskResumeAll>
     c7e:	80 e0       	ldi	r24, 0x00	; 0
     c80:	0f 90       	pop	r0
     c82:	0f 90       	pop	r0
     c84:	0f 90       	pop	r0
     c86:	0f 90       	pop	r0
     c88:	0f 90       	pop	r0
     c8a:	df 91       	pop	r29
     c8c:	cf 91       	pop	r28
     c8e:	1f 91       	pop	r17
     c90:	0f 91       	pop	r16
     c92:	ff 90       	pop	r15
     c94:	ef 90       	pop	r14
     c96:	df 90       	pop	r13
     c98:	cf 90       	pop	r12
     c9a:	08 95       	ret

00000c9c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     c9c:	8f 92       	push	r8
     c9e:	9f 92       	push	r9
     ca0:	bf 92       	push	r11
     ca2:	cf 92       	push	r12
     ca4:	df 92       	push	r13
     ca6:	ef 92       	push	r14
     ca8:	ff 92       	push	r15
     caa:	0f 93       	push	r16
     cac:	1f 93       	push	r17
     cae:	cf 93       	push	r28
     cb0:	df 93       	push	r29
     cb2:	00 d0       	rcall	.+0      	; 0xcb4 <xQueueGenericReceive+0x18>
     cb4:	00 d0       	rcall	.+0      	; 0xcb6 <xQueueGenericReceive+0x1a>
     cb6:	1f 92       	push	r1
     cb8:	cd b7       	in	r28, 0x3d	; 61
     cba:	de b7       	in	r29, 0x3e	; 62
     cbc:	8c 01       	movw	r16, r24
     cbe:	6b 01       	movw	r12, r22
     cc0:	5d 83       	std	Y+5, r21	; 0x05
     cc2:	4c 83       	std	Y+4, r20	; 0x04
     cc4:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
     cc6:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     cc8:	0f b6       	in	r0, 0x3f	; 63
     cca:	f8 94       	cli
     ccc:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     cce:	f8 01       	movw	r30, r16
     cd0:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     cd2:	ff 20       	and	r15, r15
     cd4:	91 f1       	breq	.+100    	; 0xd3a <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     cd6:	86 80       	ldd	r8, Z+6	; 0x06
     cd8:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     cda:	b6 01       	movw	r22, r12
     cdc:	c8 01       	movw	r24, r16
     cde:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     ce2:	b1 10       	cpse	r11, r1
     ce4:	19 c0       	rjmp	.+50     	; 0xd18 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     ce6:	fa 94       	dec	r15
     ce8:	f8 01       	movw	r30, r16
     cea:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     cec:	80 81       	ld	r24, Z
     cee:	91 81       	ldd	r25, Z+1	; 0x01
     cf0:	89 2b       	or	r24, r25
     cf2:	29 f4       	brne	.+10     	; 0xcfe <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     cf4:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <pvTaskIncrementMutexHeldCount>
     cf8:	f8 01       	movw	r30, r16
     cfa:	93 83       	std	Z+3, r25	; 0x03
     cfc:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     cfe:	f8 01       	movw	r30, r16
     d00:	80 85       	ldd	r24, Z+8	; 0x08
     d02:	88 23       	and	r24, r24
     d04:	b1 f0       	breq	.+44     	; 0xd32 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     d06:	c8 01       	movw	r24, r16
     d08:	08 96       	adiw	r24, 0x08	; 8
     d0a:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskRemoveFromEventList>
     d0e:	88 23       	and	r24, r24
     d10:	81 f0       	breq	.+32     	; 0xd32 <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
     d12:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
     d16:	0d c0       	rjmp	.+26     	; 0xd32 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     d18:	f8 01       	movw	r30, r16
     d1a:	97 82       	std	Z+7, r9	; 0x07
     d1c:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d1e:	81 89       	ldd	r24, Z+17	; 0x11
     d20:	88 23       	and	r24, r24
     d22:	39 f0       	breq	.+14     	; 0xd32 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d24:	c8 01       	movw	r24, r16
     d26:	41 96       	adiw	r24, 0x11	; 17
     d28:	0e 94 3f 0b 	call	0x167e	; 0x167e <xTaskRemoveFromEventList>
     d2c:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     d2e:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     d32:	0f 90       	pop	r0
     d34:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     d36:	81 e0       	ldi	r24, 0x01	; 1
     d38:	61 c0       	rjmp	.+194    	; 0xdfc <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     d3a:	8c 81       	ldd	r24, Y+4	; 0x04
     d3c:	9d 81       	ldd	r25, Y+5	; 0x05
     d3e:	89 2b       	or	r24, r25
     d40:	21 f4       	brne	.+8      	; 0xd4a <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     d42:	0f 90       	pop	r0
     d44:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     d46:	80 e0       	ldi	r24, 0x00	; 0
     d48:	59 c0       	rjmp	.+178    	; 0xdfc <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
     d4a:	e1 10       	cpse	r14, r1
     d4c:	06 c0       	rjmp	.+12     	; 0xd5a <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     d4e:	ce 01       	movw	r24, r28
     d50:	01 96       	adiw	r24, 0x01	; 1
     d52:	0e 94 87 0b 	call	0x170e	; 0x170e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     d56:	ee 24       	eor	r14, r14
     d58:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     d5a:	0f 90       	pop	r0
     d5c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     d5e:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     d62:	0f b6       	in	r0, 0x3f	; 63
     d64:	f8 94       	cli
     d66:	0f 92       	push	r0
     d68:	f8 01       	movw	r30, r16
     d6a:	85 8d       	ldd	r24, Z+29	; 0x1d
     d6c:	8f 3f       	cpi	r24, 0xFF	; 255
     d6e:	09 f4       	brne	.+2      	; 0xd72 <xQueueGenericReceive+0xd6>
     d70:	15 8e       	std	Z+29, r1	; 0x1d
     d72:	f8 01       	movw	r30, r16
     d74:	86 8d       	ldd	r24, Z+30	; 0x1e
     d76:	8f 3f       	cpi	r24, 0xFF	; 255
     d78:	09 f4       	brne	.+2      	; 0xd7c <xQueueGenericReceive+0xe0>
     d7a:	16 8e       	std	Z+30, r1	; 0x1e
     d7c:	0f 90       	pop	r0
     d7e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     d80:	be 01       	movw	r22, r28
     d82:	6c 5f       	subi	r22, 0xFC	; 252
     d84:	7f 4f       	sbci	r23, 0xFF	; 255
     d86:	ce 01       	movw	r24, r28
     d88:	01 96       	adiw	r24, 0x01	; 1
     d8a:	0e 94 92 0b 	call	0x1724	; 0x1724 <xTaskCheckForTimeOut>
     d8e:	81 11       	cpse	r24, r1
     d90:	29 c0       	rjmp	.+82     	; 0xde4 <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     d92:	c8 01       	movw	r24, r16
     d94:	0e 94 71 04 	call	0x8e2	; 0x8e2 <prvIsQueueEmpty>
     d98:	88 23       	and	r24, r24
     d9a:	f1 f0       	breq	.+60     	; 0xdd8 <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d9c:	f8 01       	movw	r30, r16
     d9e:	80 81       	ld	r24, Z
     da0:	91 81       	ldd	r25, Z+1	; 0x01
     da2:	89 2b       	or	r24, r25
     da4:	49 f4       	brne	.+18     	; 0xdb8 <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
     da6:	0f b6       	in	r0, 0x3f	; 63
     da8:	f8 94       	cli
     daa:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     dac:	82 81       	ldd	r24, Z+2	; 0x02
     dae:	93 81       	ldd	r25, Z+3	; 0x03
     db0:	0e 94 cf 0b 	call	0x179e	; 0x179e <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     db4:	0f 90       	pop	r0
     db6:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     db8:	6c 81       	ldd	r22, Y+4	; 0x04
     dba:	7d 81       	ldd	r23, Y+5	; 0x05
     dbc:	c8 01       	movw	r24, r16
     dbe:	41 96       	adiw	r24, 0x11	; 17
     dc0:	0e 94 2d 0b 	call	0x165a	; 0x165a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     dc4:	c8 01       	movw	r24, r16
     dc6:	0e 94 05 05 	call	0xa0a	; 0xa0a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     dca:	0e 94 20 0a 	call	0x1440	; 0x1440 <xTaskResumeAll>
     dce:	81 11       	cpse	r24, r1
     dd0:	7b cf       	rjmp	.-266    	; 0xcc8 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
     dd2:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
     dd6:	78 cf       	rjmp	.-272    	; 0xcc8 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     dd8:	c8 01       	movw	r24, r16
     dda:	0e 94 05 05 	call	0xa0a	; 0xa0a <prvUnlockQueue>
				( void ) xTaskResumeAll();
     dde:	0e 94 20 0a 	call	0x1440	; 0x1440 <xTaskResumeAll>
     de2:	72 cf       	rjmp	.-284    	; 0xcc8 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     de4:	c8 01       	movw	r24, r16
     de6:	0e 94 05 05 	call	0xa0a	; 0xa0a <prvUnlockQueue>
			( void ) xTaskResumeAll();
     dea:	0e 94 20 0a 	call	0x1440	; 0x1440 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     dee:	c8 01       	movw	r24, r16
     df0:	0e 94 71 04 	call	0x8e2	; 0x8e2 <prvIsQueueEmpty>
     df4:	88 23       	and	r24, r24
     df6:	09 f4       	brne	.+2      	; 0xdfa <xQueueGenericReceive+0x15e>
     df8:	67 cf       	rjmp	.-306    	; 0xcc8 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     dfa:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     dfc:	0f 90       	pop	r0
     dfe:	0f 90       	pop	r0
     e00:	0f 90       	pop	r0
     e02:	0f 90       	pop	r0
     e04:	0f 90       	pop	r0
     e06:	df 91       	pop	r29
     e08:	cf 91       	pop	r28
     e0a:	1f 91       	pop	r17
     e0c:	0f 91       	pop	r16
     e0e:	ff 90       	pop	r15
     e10:	ef 90       	pop	r14
     e12:	df 90       	pop	r13
     e14:	cf 90       	pop	r12
     e16:	bf 90       	pop	r11
     e18:	9f 90       	pop	r9
     e1a:	8f 90       	pop	r8
     e1c:	08 95       	ret

00000e1e <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     e1e:	e0 91 55 05 	lds	r30, 0x0555	; 0x800555 <pxDelayedTaskList>
     e22:	f0 91 56 05 	lds	r31, 0x0556	; 0x800556 <pxDelayedTaskList+0x1>
     e26:	80 81       	ld	r24, Z
     e28:	81 11       	cpse	r24, r1
     e2a:	07 c0       	rjmp	.+14     	; 0xe3a <prvResetNextTaskUnblockTime+0x1c>
     e2c:	8f ef       	ldi	r24, 0xFF	; 255
     e2e:	9f ef       	ldi	r25, 0xFF	; 255
     e30:	90 93 2d 05 	sts	0x052D, r25	; 0x80052d <xNextTaskUnblockTime+0x1>
     e34:	80 93 2c 05 	sts	0x052C, r24	; 0x80052c <xNextTaskUnblockTime>
     e38:	08 95       	ret
     e3a:	e0 91 55 05 	lds	r30, 0x0555	; 0x800555 <pxDelayedTaskList>
     e3e:	f0 91 56 05 	lds	r31, 0x0556	; 0x800556 <pxDelayedTaskList+0x1>
     e42:	05 80       	ldd	r0, Z+5	; 0x05
     e44:	f6 81       	ldd	r31, Z+6	; 0x06
     e46:	e0 2d       	mov	r30, r0
     e48:	06 80       	ldd	r0, Z+6	; 0x06
     e4a:	f7 81       	ldd	r31, Z+7	; 0x07
     e4c:	e0 2d       	mov	r30, r0
     e4e:	82 81       	ldd	r24, Z+2	; 0x02
     e50:	93 81       	ldd	r25, Z+3	; 0x03
     e52:	90 93 2d 05 	sts	0x052D, r25	; 0x80052d <xNextTaskUnblockTime+0x1>
     e56:	80 93 2c 05 	sts	0x052C, r24	; 0x80052c <xNextTaskUnblockTime>
     e5a:	08 95       	ret

00000e5c <prvDeleteTCB>:
     e5c:	cf 93       	push	r28
     e5e:	df 93       	push	r29
     e60:	ec 01       	movw	r28, r24
     e62:	8f 89       	ldd	r24, Y+23	; 0x17
     e64:	98 8d       	ldd	r25, Y+24	; 0x18
     e66:	0e 94 58 02 	call	0x4b0	; 0x4b0 <vPortFree>
     e6a:	ce 01       	movw	r24, r28
     e6c:	0e 94 58 02 	call	0x4b0	; 0x4b0 <vPortFree>
     e70:	df 91       	pop	r29
     e72:	cf 91       	pop	r28
     e74:	08 95       	ret

00000e76 <prvInitialiseNewTask>:
     e76:	6f 92       	push	r6
     e78:	7f 92       	push	r7
     e7a:	8f 92       	push	r8
     e7c:	9f 92       	push	r9
     e7e:	af 92       	push	r10
     e80:	bf 92       	push	r11
     e82:	cf 92       	push	r12
     e84:	df 92       	push	r13
     e86:	ef 92       	push	r14
     e88:	0f 93       	push	r16
     e8a:	1f 93       	push	r17
     e8c:	cf 93       	push	r28
     e8e:	df 93       	push	r29
     e90:	cd b7       	in	r28, 0x3d	; 61
     e92:	de b7       	in	r29, 0x3e	; 62
     e94:	4c 01       	movw	r8, r24
     e96:	f5 01       	movw	r30, r10
     e98:	87 89       	ldd	r24, Z+23	; 0x17
     e9a:	90 8d       	ldd	r25, Z+24	; 0x18
     e9c:	21 50       	subi	r18, 0x01	; 1
     e9e:	31 09       	sbc	r19, r1
     ea0:	3c 01       	movw	r6, r24
     ea2:	62 0e       	add	r6, r18
     ea4:	73 1e       	adc	r7, r19
     ea6:	20 e0       	ldi	r18, 0x00	; 0
     ea8:	0f c0       	rjmp	.+30     	; 0xec8 <prvInitialiseNewTask+0x52>
     eaa:	82 2f       	mov	r24, r18
     eac:	90 e0       	ldi	r25, 0x00	; 0
     eae:	fb 01       	movw	r30, r22
     eb0:	e8 0f       	add	r30, r24
     eb2:	f9 1f       	adc	r31, r25
     eb4:	30 81       	ld	r19, Z
     eb6:	d5 01       	movw	r26, r10
     eb8:	a8 0f       	add	r26, r24
     eba:	b9 1f       	adc	r27, r25
     ebc:	59 96       	adiw	r26, 0x19	; 25
     ebe:	3c 93       	st	X, r19
     ec0:	80 81       	ld	r24, Z
     ec2:	88 23       	and	r24, r24
     ec4:	19 f0       	breq	.+6      	; 0xecc <prvInitialiseNewTask+0x56>
     ec6:	2f 5f       	subi	r18, 0xFF	; 255
     ec8:	28 30       	cpi	r18, 0x08	; 8
     eca:	78 f3       	brcs	.-34     	; 0xeaa <prvInitialiseNewTask+0x34>
     ecc:	f5 01       	movw	r30, r10
     ece:	10 a2       	std	Z+32, r1	; 0x20
     ed0:	f4 e0       	ldi	r31, 0x04	; 4
     ed2:	fe 15       	cp	r31, r14
     ed4:	18 f4       	brcc	.+6      	; 0xedc <prvInitialiseNewTask+0x66>
     ed6:	68 94       	set
     ed8:	ee 24       	eor	r14, r14
     eda:	e2 f8       	bld	r14, 2
     edc:	f5 01       	movw	r30, r10
     ede:	e6 8a       	std	Z+22, r14	; 0x16
     ee0:	e1 a2       	std	Z+33, r14	; 0x21
     ee2:	12 a2       	std	Z+34, r1	; 0x22
     ee4:	c5 01       	movw	r24, r10
     ee6:	02 96       	adiw	r24, 0x02	; 2
     ee8:	0e 94 99 02 	call	0x532	; 0x532 <vListInitialiseItem>
     eec:	c5 01       	movw	r24, r10
     eee:	0c 96       	adiw	r24, 0x0c	; 12
     ef0:	0e 94 99 02 	call	0x532	; 0x532 <vListInitialiseItem>
     ef4:	f5 01       	movw	r30, r10
     ef6:	b1 86       	std	Z+9, r11	; 0x09
     ef8:	a0 86       	std	Z+8, r10	; 0x08
     efa:	85 e0       	ldi	r24, 0x05	; 5
     efc:	90 e0       	ldi	r25, 0x00	; 0
     efe:	8e 19       	sub	r24, r14
     f00:	91 09       	sbc	r25, r1
     f02:	95 87       	std	Z+13, r25	; 0x0d
     f04:	84 87       	std	Z+12, r24	; 0x0c
     f06:	b3 8a       	std	Z+19, r11	; 0x13
     f08:	a2 8a       	std	Z+18, r10	; 0x12
     f0a:	13 a2       	std	Z+35, r1	; 0x23
     f0c:	14 a2       	std	Z+36, r1	; 0x24
     f0e:	15 a2       	std	Z+37, r1	; 0x25
     f10:	16 a2       	std	Z+38, r1	; 0x26
     f12:	17 a2       	std	Z+39, r1	; 0x27
     f14:	a8 01       	movw	r20, r16
     f16:	b4 01       	movw	r22, r8
     f18:	c3 01       	movw	r24, r6
     f1a:	0e 94 1e 03 	call	0x63c	; 0x63c <pxPortInitialiseStack>
     f1e:	f5 01       	movw	r30, r10
     f20:	91 83       	std	Z+1, r25	; 0x01
     f22:	80 83       	st	Z, r24
     f24:	c1 14       	cp	r12, r1
     f26:	d1 04       	cpc	r13, r1
     f28:	19 f0       	breq	.+6      	; 0xf30 <prvInitialiseNewTask+0xba>
     f2a:	f6 01       	movw	r30, r12
     f2c:	b1 82       	std	Z+1, r11	; 0x01
     f2e:	a0 82       	st	Z, r10
     f30:	df 91       	pop	r29
     f32:	cf 91       	pop	r28
     f34:	1f 91       	pop	r17
     f36:	0f 91       	pop	r16
     f38:	ef 90       	pop	r14
     f3a:	df 90       	pop	r13
     f3c:	cf 90       	pop	r12
     f3e:	bf 90       	pop	r11
     f40:	af 90       	pop	r10
     f42:	9f 90       	pop	r9
     f44:	8f 90       	pop	r8
     f46:	7f 90       	pop	r7
     f48:	6f 90       	pop	r6
     f4a:	08 95       	ret

00000f4c <prvInitialiseTaskLists>:
     f4c:	cf 93       	push	r28
     f4e:	c0 e0       	ldi	r28, 0x00	; 0
     f50:	10 c0       	rjmp	.+32     	; 0xf72 <prvInitialiseTaskLists+0x26>
     f52:	8c 2f       	mov	r24, r28
     f54:	90 e0       	ldi	r25, 0x00	; 0
     f56:	9c 01       	movw	r18, r24
     f58:	22 0f       	add	r18, r18
     f5a:	33 1f       	adc	r19, r19
     f5c:	22 0f       	add	r18, r18
     f5e:	33 1f       	adc	r19, r19
     f60:	22 0f       	add	r18, r18
     f62:	33 1f       	adc	r19, r19
     f64:	82 0f       	add	r24, r18
     f66:	93 1f       	adc	r25, r19
     f68:	87 59       	subi	r24, 0x97	; 151
     f6a:	9a 4f       	sbci	r25, 0xFA	; 250
     f6c:	0e 94 8b 02 	call	0x516	; 0x516 <vListInitialise>
     f70:	cf 5f       	subi	r28, 0xFF	; 255
     f72:	c5 30       	cpi	r28, 0x05	; 5
     f74:	70 f3       	brcs	.-36     	; 0xf52 <prvInitialiseTaskLists+0x6>
     f76:	80 e6       	ldi	r24, 0x60	; 96
     f78:	95 e0       	ldi	r25, 0x05	; 5
     f7a:	0e 94 8b 02 	call	0x516	; 0x516 <vListInitialise>
     f7e:	87 e5       	ldi	r24, 0x57	; 87
     f80:	95 e0       	ldi	r25, 0x05	; 5
     f82:	0e 94 8b 02 	call	0x516	; 0x516 <vListInitialise>
     f86:	8a e4       	ldi	r24, 0x4A	; 74
     f88:	95 e0       	ldi	r25, 0x05	; 5
     f8a:	0e 94 8b 02 	call	0x516	; 0x516 <vListInitialise>
     f8e:	81 e4       	ldi	r24, 0x41	; 65
     f90:	95 e0       	ldi	r25, 0x05	; 5
     f92:	0e 94 8b 02 	call	0x516	; 0x516 <vListInitialise>
     f96:	87 e3       	ldi	r24, 0x37	; 55
     f98:	95 e0       	ldi	r25, 0x05	; 5
     f9a:	0e 94 8b 02 	call	0x516	; 0x516 <vListInitialise>
     f9e:	80 e6       	ldi	r24, 0x60	; 96
     fa0:	95 e0       	ldi	r25, 0x05	; 5
     fa2:	90 93 56 05 	sts	0x0556, r25	; 0x800556 <pxDelayedTaskList+0x1>
     fa6:	80 93 55 05 	sts	0x0555, r24	; 0x800555 <pxDelayedTaskList>
     faa:	87 e5       	ldi	r24, 0x57	; 87
     fac:	95 e0       	ldi	r25, 0x05	; 5
     fae:	90 93 54 05 	sts	0x0554, r25	; 0x800554 <pxOverflowDelayedTaskList+0x1>
     fb2:	80 93 53 05 	sts	0x0553, r24	; 0x800553 <pxOverflowDelayedTaskList>
     fb6:	cf 91       	pop	r28
     fb8:	08 95       	ret

00000fba <prvAddNewTaskToReadyList>:
     fba:	cf 93       	push	r28
     fbc:	df 93       	push	r29
     fbe:	ec 01       	movw	r28, r24
     fc0:	0f b6       	in	r0, 0x3f	; 63
     fc2:	f8 94       	cli
     fc4:	0f 92       	push	r0
     fc6:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <uxCurrentNumberOfTasks>
     fca:	8f 5f       	subi	r24, 0xFF	; 255
     fcc:	80 93 36 05 	sts	0x0536, r24	; 0x800536 <uxCurrentNumberOfTasks>
     fd0:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <pxCurrentTCB>
     fd4:	90 91 97 05 	lds	r25, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
     fd8:	89 2b       	or	r24, r25
     fda:	59 f4       	brne	.+22     	; 0xff2 <prvAddNewTaskToReadyList+0x38>
     fdc:	d0 93 97 05 	sts	0x0597, r29	; 0x800597 <pxCurrentTCB+0x1>
     fe0:	c0 93 96 05 	sts	0x0596, r28	; 0x800596 <pxCurrentTCB>
     fe4:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <uxCurrentNumberOfTasks>
     fe8:	81 30       	cpi	r24, 0x01	; 1
     fea:	99 f4       	brne	.+38     	; 0x1012 <prvAddNewTaskToReadyList+0x58>
     fec:	0e 94 a6 07 	call	0xf4c	; 0xf4c <prvInitialiseTaskLists>
     ff0:	10 c0       	rjmp	.+32     	; 0x1012 <prvAddNewTaskToReadyList+0x58>
     ff2:	80 91 32 05 	lds	r24, 0x0532	; 0x800532 <xSchedulerRunning>
     ff6:	81 11       	cpse	r24, r1
     ff8:	0c c0       	rjmp	.+24     	; 0x1012 <prvAddNewTaskToReadyList+0x58>
     ffa:	e0 91 96 05 	lds	r30, 0x0596	; 0x800596 <pxCurrentTCB>
     ffe:	f0 91 97 05 	lds	r31, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    1002:	96 89       	ldd	r25, Z+22	; 0x16
    1004:	8e 89       	ldd	r24, Y+22	; 0x16
    1006:	89 17       	cp	r24, r25
    1008:	20 f0       	brcs	.+8      	; 0x1012 <prvAddNewTaskToReadyList+0x58>
    100a:	d0 93 97 05 	sts	0x0597, r29	; 0x800597 <pxCurrentTCB+0x1>
    100e:	c0 93 96 05 	sts	0x0596, r28	; 0x800596 <pxCurrentTCB>
    1012:	80 91 2e 05 	lds	r24, 0x052E	; 0x80052e <uxTaskNumber>
    1016:	8f 5f       	subi	r24, 0xFF	; 255
    1018:	80 93 2e 05 	sts	0x052E, r24	; 0x80052e <uxTaskNumber>
    101c:	8e 89       	ldd	r24, Y+22	; 0x16
    101e:	90 91 33 05 	lds	r25, 0x0533	; 0x800533 <uxTopReadyPriority>
    1022:	98 17       	cp	r25, r24
    1024:	10 f4       	brcc	.+4      	; 0x102a <prvAddNewTaskToReadyList+0x70>
    1026:	80 93 33 05 	sts	0x0533, r24	; 0x800533 <uxTopReadyPriority>
    102a:	90 e0       	ldi	r25, 0x00	; 0
    102c:	9c 01       	movw	r18, r24
    102e:	22 0f       	add	r18, r18
    1030:	33 1f       	adc	r19, r19
    1032:	22 0f       	add	r18, r18
    1034:	33 1f       	adc	r19, r19
    1036:	22 0f       	add	r18, r18
    1038:	33 1f       	adc	r19, r19
    103a:	82 0f       	add	r24, r18
    103c:	93 1f       	adc	r25, r19
    103e:	be 01       	movw	r22, r28
    1040:	6e 5f       	subi	r22, 0xFE	; 254
    1042:	7f 4f       	sbci	r23, 0xFF	; 255
    1044:	87 59       	subi	r24, 0x97	; 151
    1046:	9a 4f       	sbci	r25, 0xFA	; 250
    1048:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInsertEnd>
    104c:	0f 90       	pop	r0
    104e:	0f be       	out	0x3f, r0	; 63
    1050:	80 91 32 05 	lds	r24, 0x0532	; 0x800532 <xSchedulerRunning>
    1054:	88 23       	and	r24, r24
    1056:	51 f0       	breq	.+20     	; 0x106c <prvAddNewTaskToReadyList+0xb2>
    1058:	e0 91 96 05 	lds	r30, 0x0596	; 0x800596 <pxCurrentTCB>
    105c:	f0 91 97 05 	lds	r31, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    1060:	96 89       	ldd	r25, Z+22	; 0x16
    1062:	8e 89       	ldd	r24, Y+22	; 0x16
    1064:	98 17       	cp	r25, r24
    1066:	10 f4       	brcc	.+4      	; 0x106c <prvAddNewTaskToReadyList+0xb2>
    1068:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
    106c:	df 91       	pop	r29
    106e:	cf 91       	pop	r28
    1070:	08 95       	ret

00001072 <prvAddCurrentTaskToDelayedList>:
    1072:	ff 92       	push	r15
    1074:	0f 93       	push	r16
    1076:	1f 93       	push	r17
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	ec 01       	movw	r28, r24
    107e:	f6 2e       	mov	r15, r22
    1080:	00 91 34 05 	lds	r16, 0x0534	; 0x800534 <xTickCount>
    1084:	10 91 35 05 	lds	r17, 0x0535	; 0x800535 <xTickCount+0x1>
    1088:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <pxCurrentTCB>
    108c:	90 91 97 05 	lds	r25, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    1090:	02 96       	adiw	r24, 0x02	; 2
    1092:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    1096:	cf 3f       	cpi	r28, 0xFF	; 255
    1098:	8f ef       	ldi	r24, 0xFF	; 255
    109a:	d8 07       	cpc	r29, r24
    109c:	69 f4       	brne	.+26     	; 0x10b8 <prvAddCurrentTaskToDelayedList+0x46>
    109e:	ff 20       	and	r15, r15
    10a0:	59 f0       	breq	.+22     	; 0x10b8 <prvAddCurrentTaskToDelayedList+0x46>
    10a2:	60 91 96 05 	lds	r22, 0x0596	; 0x800596 <pxCurrentTCB>
    10a6:	70 91 97 05 	lds	r23, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    10aa:	6e 5f       	subi	r22, 0xFE	; 254
    10ac:	7f 4f       	sbci	r23, 0xFF	; 255
    10ae:	87 e3       	ldi	r24, 0x37	; 55
    10b0:	95 e0       	ldi	r25, 0x05	; 5
    10b2:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInsertEnd>
    10b6:	2f c0       	rjmp	.+94     	; 0x1116 <prvAddCurrentTaskToDelayedList+0xa4>
    10b8:	c0 0f       	add	r28, r16
    10ba:	d1 1f       	adc	r29, r17
    10bc:	e0 91 96 05 	lds	r30, 0x0596	; 0x800596 <pxCurrentTCB>
    10c0:	f0 91 97 05 	lds	r31, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    10c4:	d3 83       	std	Z+3, r29	; 0x03
    10c6:	c2 83       	std	Z+2, r28	; 0x02
    10c8:	c0 17       	cp	r28, r16
    10ca:	d1 07       	cpc	r29, r17
    10cc:	68 f4       	brcc	.+26     	; 0x10e8 <prvAddCurrentTaskToDelayedList+0x76>
    10ce:	60 91 96 05 	lds	r22, 0x0596	; 0x800596 <pxCurrentTCB>
    10d2:	70 91 97 05 	lds	r23, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    10d6:	80 91 53 05 	lds	r24, 0x0553	; 0x800553 <pxOverflowDelayedTaskList>
    10da:	90 91 54 05 	lds	r25, 0x0554	; 0x800554 <pxOverflowDelayedTaskList+0x1>
    10de:	6e 5f       	subi	r22, 0xFE	; 254
    10e0:	7f 4f       	sbci	r23, 0xFF	; 255
    10e2:	0e 94 be 02 	call	0x57c	; 0x57c <vListInsert>
    10e6:	17 c0       	rjmp	.+46     	; 0x1116 <prvAddCurrentTaskToDelayedList+0xa4>
    10e8:	60 91 96 05 	lds	r22, 0x0596	; 0x800596 <pxCurrentTCB>
    10ec:	70 91 97 05 	lds	r23, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    10f0:	80 91 55 05 	lds	r24, 0x0555	; 0x800555 <pxDelayedTaskList>
    10f4:	90 91 56 05 	lds	r25, 0x0556	; 0x800556 <pxDelayedTaskList+0x1>
    10f8:	6e 5f       	subi	r22, 0xFE	; 254
    10fa:	7f 4f       	sbci	r23, 0xFF	; 255
    10fc:	0e 94 be 02 	call	0x57c	; 0x57c <vListInsert>
    1100:	80 91 2c 05 	lds	r24, 0x052C	; 0x80052c <xNextTaskUnblockTime>
    1104:	90 91 2d 05 	lds	r25, 0x052D	; 0x80052d <xNextTaskUnblockTime+0x1>
    1108:	c8 17       	cp	r28, r24
    110a:	d9 07       	cpc	r29, r25
    110c:	20 f4       	brcc	.+8      	; 0x1116 <prvAddCurrentTaskToDelayedList+0xa4>
    110e:	d0 93 2d 05 	sts	0x052D, r29	; 0x80052d <xNextTaskUnblockTime+0x1>
    1112:	c0 93 2c 05 	sts	0x052C, r28	; 0x80052c <xNextTaskUnblockTime>
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	0f 91       	pop	r16
    111e:	ff 90       	pop	r15
    1120:	08 95       	ret

00001122 <xTaskCreate>:
    1122:	2f 92       	push	r2
    1124:	3f 92       	push	r3
    1126:	4f 92       	push	r4
    1128:	5f 92       	push	r5
    112a:	6f 92       	push	r6
    112c:	7f 92       	push	r7
    112e:	8f 92       	push	r8
    1130:	9f 92       	push	r9
    1132:	af 92       	push	r10
    1134:	bf 92       	push	r11
    1136:	cf 92       	push	r12
    1138:	df 92       	push	r13
    113a:	ef 92       	push	r14
    113c:	ff 92       	push	r15
    113e:	0f 93       	push	r16
    1140:	1f 93       	push	r17
    1142:	cf 93       	push	r28
    1144:	df 93       	push	r29
    1146:	3c 01       	movw	r6, r24
    1148:	1b 01       	movw	r2, r22
    114a:	5a 01       	movw	r10, r20
    114c:	29 01       	movw	r4, r18
    114e:	ca 01       	movw	r24, r20
    1150:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pvPortMalloc>
    1154:	6c 01       	movw	r12, r24
    1156:	89 2b       	or	r24, r25
    1158:	71 f0       	breq	.+28     	; 0x1176 <xTaskCreate+0x54>
    115a:	88 e2       	ldi	r24, 0x28	; 40
    115c:	90 e0       	ldi	r25, 0x00	; 0
    115e:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pvPortMalloc>
    1162:	ec 01       	movw	r28, r24
    1164:	89 2b       	or	r24, r25
    1166:	19 f0       	breq	.+6      	; 0x116e <xTaskCreate+0x4c>
    1168:	d8 8e       	std	Y+24, r13	; 0x18
    116a:	cf 8a       	std	Y+23, r12	; 0x17
    116c:	06 c0       	rjmp	.+12     	; 0x117a <xTaskCreate+0x58>
    116e:	c6 01       	movw	r24, r12
    1170:	0e 94 58 02 	call	0x4b0	; 0x4b0 <vPortFree>
    1174:	02 c0       	rjmp	.+4      	; 0x117a <xTaskCreate+0x58>
    1176:	c0 e0       	ldi	r28, 0x00	; 0
    1178:	d0 e0       	ldi	r29, 0x00	; 0
    117a:	20 97       	sbiw	r28, 0x00	; 0
    117c:	91 f0       	breq	.+36     	; 0x11a2 <xTaskCreate+0x80>
    117e:	95 01       	movw	r18, r10
    1180:	40 e0       	ldi	r20, 0x00	; 0
    1182:	50 e0       	ldi	r21, 0x00	; 0
    1184:	81 2c       	mov	r8, r1
    1186:	91 2c       	mov	r9, r1
    1188:	5e 01       	movw	r10, r28
    118a:	67 01       	movw	r12, r14
    118c:	e0 2e       	mov	r14, r16
    118e:	82 01       	movw	r16, r4
    1190:	b1 01       	movw	r22, r2
    1192:	c3 01       	movw	r24, r6
    1194:	0e 94 3b 07 	call	0xe76	; 0xe76 <prvInitialiseNewTask>
    1198:	ce 01       	movw	r24, r28
    119a:	0e 94 dd 07 	call	0xfba	; 0xfba <prvAddNewTaskToReadyList>
    119e:	81 e0       	ldi	r24, 0x01	; 1
    11a0:	01 c0       	rjmp	.+2      	; 0x11a4 <xTaskCreate+0x82>
    11a2:	8f ef       	ldi	r24, 0xFF	; 255
    11a4:	df 91       	pop	r29
    11a6:	cf 91       	pop	r28
    11a8:	1f 91       	pop	r17
    11aa:	0f 91       	pop	r16
    11ac:	ff 90       	pop	r15
    11ae:	ef 90       	pop	r14
    11b0:	df 90       	pop	r13
    11b2:	cf 90       	pop	r12
    11b4:	bf 90       	pop	r11
    11b6:	af 90       	pop	r10
    11b8:	9f 90       	pop	r9
    11ba:	8f 90       	pop	r8
    11bc:	7f 90       	pop	r7
    11be:	6f 90       	pop	r6
    11c0:	5f 90       	pop	r5
    11c2:	4f 90       	pop	r4
    11c4:	3f 90       	pop	r3
    11c6:	2f 90       	pop	r2
    11c8:	08 95       	ret

000011ca <vTaskDelete>:
    11ca:	0f 93       	push	r16
    11cc:	1f 93       	push	r17
    11ce:	cf 93       	push	r28
    11d0:	df 93       	push	r29
    11d2:	ec 01       	movw	r28, r24
    11d4:	0f b6       	in	r0, 0x3f	; 63
    11d6:	f8 94       	cli
    11d8:	0f 92       	push	r0
    11da:	89 2b       	or	r24, r25
    11dc:	21 f4       	brne	.+8      	; 0x11e6 <vTaskDelete+0x1c>
    11de:	c0 91 96 05 	lds	r28, 0x0596	; 0x800596 <pxCurrentTCB>
    11e2:	d0 91 97 05 	lds	r29, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    11e6:	8e 01       	movw	r16, r28
    11e8:	0e 5f       	subi	r16, 0xFE	; 254
    11ea:	1f 4f       	sbci	r17, 0xFF	; 255
    11ec:	c8 01       	movw	r24, r16
    11ee:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    11f2:	8c 89       	ldd	r24, Y+20	; 0x14
    11f4:	9d 89       	ldd	r25, Y+21	; 0x15
    11f6:	89 2b       	or	r24, r25
    11f8:	21 f0       	breq	.+8      	; 0x1202 <vTaskDelete+0x38>
    11fa:	ce 01       	movw	r24, r28
    11fc:	0c 96       	adiw	r24, 0x0c	; 12
    11fe:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    1202:	80 91 2e 05 	lds	r24, 0x052E	; 0x80052e <uxTaskNumber>
    1206:	8f 5f       	subi	r24, 0xFF	; 255
    1208:	80 93 2e 05 	sts	0x052E, r24	; 0x80052e <uxTaskNumber>
    120c:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <pxCurrentTCB>
    1210:	90 91 97 05 	lds	r25, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    1214:	c8 17       	cp	r28, r24
    1216:	d9 07       	cpc	r29, r25
    1218:	59 f4       	brne	.+22     	; 0x1230 <vTaskDelete+0x66>
    121a:	b8 01       	movw	r22, r16
    121c:	81 e4       	ldi	r24, 0x41	; 65
    121e:	95 e0       	ldi	r25, 0x05	; 5
    1220:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInsertEnd>
    1224:	80 91 40 05 	lds	r24, 0x0540	; 0x800540 <uxDeletedTasksWaitingCleanUp>
    1228:	8f 5f       	subi	r24, 0xFF	; 255
    122a:	80 93 40 05 	sts	0x0540, r24	; 0x800540 <uxDeletedTasksWaitingCleanUp>
    122e:	0a c0       	rjmp	.+20     	; 0x1244 <vTaskDelete+0x7a>
    1230:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <uxCurrentNumberOfTasks>
    1234:	81 50       	subi	r24, 0x01	; 1
    1236:	80 93 36 05 	sts	0x0536, r24	; 0x800536 <uxCurrentNumberOfTasks>
    123a:	ce 01       	movw	r24, r28
    123c:	0e 94 2e 07 	call	0xe5c	; 0xe5c <prvDeleteTCB>
    1240:	0e 94 0f 07 	call	0xe1e	; 0xe1e <prvResetNextTaskUnblockTime>
    1244:	0f 90       	pop	r0
    1246:	0f be       	out	0x3f, r0	; 63
    1248:	80 91 32 05 	lds	r24, 0x0532	; 0x800532 <xSchedulerRunning>
    124c:	88 23       	and	r24, r24
    124e:	49 f0       	breq	.+18     	; 0x1262 <vTaskDelete+0x98>
    1250:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <pxCurrentTCB>
    1254:	90 91 97 05 	lds	r25, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    1258:	c8 17       	cp	r28, r24
    125a:	d9 07       	cpc	r29, r25
    125c:	11 f4       	brne	.+4      	; 0x1262 <vTaskDelete+0x98>
    125e:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
    1262:	df 91       	pop	r29
    1264:	cf 91       	pop	r28
    1266:	1f 91       	pop	r17
    1268:	0f 91       	pop	r16
    126a:	08 95       	ret

0000126c <vTaskStartScheduler>:
    126c:	ef 92       	push	r14
    126e:	ff 92       	push	r15
    1270:	0f 93       	push	r16
    1272:	0f 2e       	mov	r0, r31
    1274:	fa e2       	ldi	r31, 0x2A	; 42
    1276:	ef 2e       	mov	r14, r31
    1278:	f5 e0       	ldi	r31, 0x05	; 5
    127a:	ff 2e       	mov	r15, r31
    127c:	f0 2d       	mov	r31, r0
    127e:	00 e0       	ldi	r16, 0x00	; 0
    1280:	20 e0       	ldi	r18, 0x00	; 0
    1282:	30 e0       	ldi	r19, 0x00	; 0
    1284:	40 e5       	ldi	r20, 0x50	; 80
    1286:	50 e0       	ldi	r21, 0x00	; 0
    1288:	61 e3       	ldi	r22, 0x31	; 49
    128a:	71 e0       	ldi	r23, 0x01	; 1
    128c:	86 ed       	ldi	r24, 0xD6	; 214
    128e:	9a e0       	ldi	r25, 0x0A	; 10
    1290:	0e 94 91 08 	call	0x1122	; 0x1122 <xTaskCreate>
    1294:	81 30       	cpi	r24, 0x01	; 1
    1296:	81 f4       	brne	.+32     	; 0x12b8 <vTaskStartScheduler+0x4c>
    1298:	f8 94       	cli
    129a:	8f ef       	ldi	r24, 0xFF	; 255
    129c:	9f ef       	ldi	r25, 0xFF	; 255
    129e:	90 93 2d 05 	sts	0x052D, r25	; 0x80052d <xNextTaskUnblockTime+0x1>
    12a2:	80 93 2c 05 	sts	0x052C, r24	; 0x80052c <xNextTaskUnblockTime>
    12a6:	81 e0       	ldi	r24, 0x01	; 1
    12a8:	80 93 32 05 	sts	0x0532, r24	; 0x800532 <xSchedulerRunning>
    12ac:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <xTickCount+0x1>
    12b0:	10 92 34 05 	sts	0x0534, r1	; 0x800534 <xTickCount>
    12b4:	0e 94 8a 03 	call	0x714	; 0x714 <xPortStartScheduler>
    12b8:	0f 91       	pop	r16
    12ba:	ff 90       	pop	r15
    12bc:	ef 90       	pop	r14
    12be:	08 95       	ret

000012c0 <vTaskSuspendAll>:
    12c0:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <uxSchedulerSuspended>
    12c4:	8f 5f       	subi	r24, 0xFF	; 255
    12c6:	80 93 29 05 	sts	0x0529, r24	; 0x800529 <uxSchedulerSuspended>
    12ca:	08 95       	ret

000012cc <xTaskIncrementTick>:
    12cc:	df 92       	push	r13
    12ce:	ef 92       	push	r14
    12d0:	ff 92       	push	r15
    12d2:	0f 93       	push	r16
    12d4:	1f 93       	push	r17
    12d6:	cf 93       	push	r28
    12d8:	df 93       	push	r29
    12da:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <uxSchedulerSuspended>
    12de:	81 11       	cpse	r24, r1
    12e0:	97 c0       	rjmp	.+302    	; 0x1410 <xTaskIncrementTick+0x144>
    12e2:	e0 90 34 05 	lds	r14, 0x0534	; 0x800534 <xTickCount>
    12e6:	f0 90 35 05 	lds	r15, 0x0535	; 0x800535 <xTickCount+0x1>
    12ea:	8f ef       	ldi	r24, 0xFF	; 255
    12ec:	e8 1a       	sub	r14, r24
    12ee:	f8 0a       	sbc	r15, r24
    12f0:	f0 92 35 05 	sts	0x0535, r15	; 0x800535 <xTickCount+0x1>
    12f4:	e0 92 34 05 	sts	0x0534, r14	; 0x800534 <xTickCount>
    12f8:	e1 14       	cp	r14, r1
    12fa:	f1 04       	cpc	r15, r1
    12fc:	b9 f4       	brne	.+46     	; 0x132c <xTaskIncrementTick+0x60>
    12fe:	80 91 55 05 	lds	r24, 0x0555	; 0x800555 <pxDelayedTaskList>
    1302:	90 91 56 05 	lds	r25, 0x0556	; 0x800556 <pxDelayedTaskList+0x1>
    1306:	20 91 53 05 	lds	r18, 0x0553	; 0x800553 <pxOverflowDelayedTaskList>
    130a:	30 91 54 05 	lds	r19, 0x0554	; 0x800554 <pxOverflowDelayedTaskList+0x1>
    130e:	30 93 56 05 	sts	0x0556, r19	; 0x800556 <pxDelayedTaskList+0x1>
    1312:	20 93 55 05 	sts	0x0555, r18	; 0x800555 <pxDelayedTaskList>
    1316:	90 93 54 05 	sts	0x0554, r25	; 0x800554 <pxOverflowDelayedTaskList+0x1>
    131a:	80 93 53 05 	sts	0x0553, r24	; 0x800553 <pxOverflowDelayedTaskList>
    131e:	80 91 2f 05 	lds	r24, 0x052F	; 0x80052f <xNumOfOverflows>
    1322:	8f 5f       	subi	r24, 0xFF	; 255
    1324:	80 93 2f 05 	sts	0x052F, r24	; 0x80052f <xNumOfOverflows>
    1328:	0e 94 0f 07 	call	0xe1e	; 0xe1e <prvResetNextTaskUnblockTime>
    132c:	80 91 2c 05 	lds	r24, 0x052C	; 0x80052c <xNextTaskUnblockTime>
    1330:	90 91 2d 05 	lds	r25, 0x052D	; 0x80052d <xNextTaskUnblockTime+0x1>
    1334:	e8 16       	cp	r14, r24
    1336:	f9 06       	cpc	r15, r25
    1338:	28 f4       	brcc	.+10     	; 0x1344 <xTaskIncrementTick+0x78>
    133a:	d1 2c       	mov	r13, r1
    133c:	53 c0       	rjmp	.+166    	; 0x13e4 <xTaskIncrementTick+0x118>
    133e:	dd 24       	eor	r13, r13
    1340:	d3 94       	inc	r13
    1342:	01 c0       	rjmp	.+2      	; 0x1346 <xTaskIncrementTick+0x7a>
    1344:	d1 2c       	mov	r13, r1
    1346:	e0 91 55 05 	lds	r30, 0x0555	; 0x800555 <pxDelayedTaskList>
    134a:	f0 91 56 05 	lds	r31, 0x0556	; 0x800556 <pxDelayedTaskList+0x1>
    134e:	80 81       	ld	r24, Z
    1350:	81 11       	cpse	r24, r1
    1352:	07 c0       	rjmp	.+14     	; 0x1362 <xTaskIncrementTick+0x96>
    1354:	8f ef       	ldi	r24, 0xFF	; 255
    1356:	9f ef       	ldi	r25, 0xFF	; 255
    1358:	90 93 2d 05 	sts	0x052D, r25	; 0x80052d <xNextTaskUnblockTime+0x1>
    135c:	80 93 2c 05 	sts	0x052C, r24	; 0x80052c <xNextTaskUnblockTime>
    1360:	41 c0       	rjmp	.+130    	; 0x13e4 <xTaskIncrementTick+0x118>
    1362:	e0 91 55 05 	lds	r30, 0x0555	; 0x800555 <pxDelayedTaskList>
    1366:	f0 91 56 05 	lds	r31, 0x0556	; 0x800556 <pxDelayedTaskList+0x1>
    136a:	05 80       	ldd	r0, Z+5	; 0x05
    136c:	f6 81       	ldd	r31, Z+6	; 0x06
    136e:	e0 2d       	mov	r30, r0
    1370:	c6 81       	ldd	r28, Z+6	; 0x06
    1372:	d7 81       	ldd	r29, Z+7	; 0x07
    1374:	8a 81       	ldd	r24, Y+2	; 0x02
    1376:	9b 81       	ldd	r25, Y+3	; 0x03
    1378:	e8 16       	cp	r14, r24
    137a:	f9 06       	cpc	r15, r25
    137c:	28 f4       	brcc	.+10     	; 0x1388 <xTaskIncrementTick+0xbc>
    137e:	90 93 2d 05 	sts	0x052D, r25	; 0x80052d <xNextTaskUnblockTime+0x1>
    1382:	80 93 2c 05 	sts	0x052C, r24	; 0x80052c <xNextTaskUnblockTime>
    1386:	2e c0       	rjmp	.+92     	; 0x13e4 <xTaskIncrementTick+0x118>
    1388:	8e 01       	movw	r16, r28
    138a:	0e 5f       	subi	r16, 0xFE	; 254
    138c:	1f 4f       	sbci	r17, 0xFF	; 255
    138e:	c8 01       	movw	r24, r16
    1390:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    1394:	8c 89       	ldd	r24, Y+20	; 0x14
    1396:	9d 89       	ldd	r25, Y+21	; 0x15
    1398:	89 2b       	or	r24, r25
    139a:	21 f0       	breq	.+8      	; 0x13a4 <xTaskIncrementTick+0xd8>
    139c:	ce 01       	movw	r24, r28
    139e:	0c 96       	adiw	r24, 0x0c	; 12
    13a0:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    13a4:	8e 89       	ldd	r24, Y+22	; 0x16
    13a6:	90 91 33 05 	lds	r25, 0x0533	; 0x800533 <uxTopReadyPriority>
    13aa:	98 17       	cp	r25, r24
    13ac:	10 f4       	brcc	.+4      	; 0x13b2 <xTaskIncrementTick+0xe6>
    13ae:	80 93 33 05 	sts	0x0533, r24	; 0x800533 <uxTopReadyPriority>
    13b2:	90 e0       	ldi	r25, 0x00	; 0
    13b4:	9c 01       	movw	r18, r24
    13b6:	22 0f       	add	r18, r18
    13b8:	33 1f       	adc	r19, r19
    13ba:	22 0f       	add	r18, r18
    13bc:	33 1f       	adc	r19, r19
    13be:	22 0f       	add	r18, r18
    13c0:	33 1f       	adc	r19, r19
    13c2:	82 0f       	add	r24, r18
    13c4:	93 1f       	adc	r25, r19
    13c6:	b8 01       	movw	r22, r16
    13c8:	87 59       	subi	r24, 0x97	; 151
    13ca:	9a 4f       	sbci	r25, 0xFA	; 250
    13cc:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInsertEnd>
    13d0:	9e 89       	ldd	r25, Y+22	; 0x16
    13d2:	e0 91 96 05 	lds	r30, 0x0596	; 0x800596 <pxCurrentTCB>
    13d6:	f0 91 97 05 	lds	r31, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    13da:	86 89       	ldd	r24, Z+22	; 0x16
    13dc:	98 17       	cp	r25, r24
    13de:	08 f0       	brcs	.+2      	; 0x13e2 <xTaskIncrementTick+0x116>
    13e0:	ae cf       	rjmp	.-164    	; 0x133e <xTaskIncrementTick+0x72>
    13e2:	b1 cf       	rjmp	.-158    	; 0x1346 <xTaskIncrementTick+0x7a>
    13e4:	e0 91 96 05 	lds	r30, 0x0596	; 0x800596 <pxCurrentTCB>
    13e8:	f0 91 97 05 	lds	r31, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    13ec:	86 89       	ldd	r24, Z+22	; 0x16
    13ee:	90 e0       	ldi	r25, 0x00	; 0
    13f0:	fc 01       	movw	r30, r24
    13f2:	ee 0f       	add	r30, r30
    13f4:	ff 1f       	adc	r31, r31
    13f6:	ee 0f       	add	r30, r30
    13f8:	ff 1f       	adc	r31, r31
    13fa:	ee 0f       	add	r30, r30
    13fc:	ff 1f       	adc	r31, r31
    13fe:	8e 0f       	add	r24, r30
    1400:	9f 1f       	adc	r25, r31
    1402:	fc 01       	movw	r30, r24
    1404:	e7 59       	subi	r30, 0x97	; 151
    1406:	fa 4f       	sbci	r31, 0xFA	; 250
    1408:	80 81       	ld	r24, Z
    140a:	82 30       	cpi	r24, 0x02	; 2
    140c:	40 f4       	brcc	.+16     	; 0x141e <xTaskIncrementTick+0x152>
    140e:	09 c0       	rjmp	.+18     	; 0x1422 <xTaskIncrementTick+0x156>
    1410:	80 91 31 05 	lds	r24, 0x0531	; 0x800531 <uxPendedTicks>
    1414:	8f 5f       	subi	r24, 0xFF	; 255
    1416:	80 93 31 05 	sts	0x0531, r24	; 0x800531 <uxPendedTicks>
    141a:	d1 2c       	mov	r13, r1
    141c:	02 c0       	rjmp	.+4      	; 0x1422 <xTaskIncrementTick+0x156>
    141e:	dd 24       	eor	r13, r13
    1420:	d3 94       	inc	r13
    1422:	80 91 30 05 	lds	r24, 0x0530	; 0x800530 <xYieldPending>
    1426:	88 23       	and	r24, r24
    1428:	11 f0       	breq	.+4      	; 0x142e <xTaskIncrementTick+0x162>
    142a:	dd 24       	eor	r13, r13
    142c:	d3 94       	inc	r13
    142e:	8d 2d       	mov	r24, r13
    1430:	df 91       	pop	r29
    1432:	cf 91       	pop	r28
    1434:	1f 91       	pop	r17
    1436:	0f 91       	pop	r16
    1438:	ff 90       	pop	r15
    143a:	ef 90       	pop	r14
    143c:	df 90       	pop	r13
    143e:	08 95       	ret

00001440 <xTaskResumeAll>:
    1440:	0f 93       	push	r16
    1442:	1f 93       	push	r17
    1444:	cf 93       	push	r28
    1446:	df 93       	push	r29
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	0f 92       	push	r0
    144e:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <uxSchedulerSuspended>
    1452:	81 50       	subi	r24, 0x01	; 1
    1454:	80 93 29 05 	sts	0x0529, r24	; 0x800529 <uxSchedulerSuspended>
    1458:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <uxSchedulerSuspended>
    145c:	81 11       	cpse	r24, r1
    145e:	58 c0       	rjmp	.+176    	; 0x1510 <xTaskResumeAll+0xd0>
    1460:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <uxCurrentNumberOfTasks>
    1464:	81 11       	cpse	r24, r1
    1466:	33 c0       	rjmp	.+102    	; 0x14ce <xTaskResumeAll+0x8e>
    1468:	56 c0       	rjmp	.+172    	; 0x1516 <xTaskResumeAll+0xd6>
    146a:	e0 91 4f 05 	lds	r30, 0x054F	; 0x80054f <xPendingReadyList+0x5>
    146e:	f0 91 50 05 	lds	r31, 0x0550	; 0x800550 <xPendingReadyList+0x6>
    1472:	c6 81       	ldd	r28, Z+6	; 0x06
    1474:	d7 81       	ldd	r29, Z+7	; 0x07
    1476:	ce 01       	movw	r24, r28
    1478:	0c 96       	adiw	r24, 0x0c	; 12
    147a:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    147e:	8e 01       	movw	r16, r28
    1480:	0e 5f       	subi	r16, 0xFE	; 254
    1482:	1f 4f       	sbci	r17, 0xFF	; 255
    1484:	c8 01       	movw	r24, r16
    1486:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    148a:	8e 89       	ldd	r24, Y+22	; 0x16
    148c:	90 91 33 05 	lds	r25, 0x0533	; 0x800533 <uxTopReadyPriority>
    1490:	98 17       	cp	r25, r24
    1492:	10 f4       	brcc	.+4      	; 0x1498 <xTaskResumeAll+0x58>
    1494:	80 93 33 05 	sts	0x0533, r24	; 0x800533 <uxTopReadyPriority>
    1498:	90 e0       	ldi	r25, 0x00	; 0
    149a:	9c 01       	movw	r18, r24
    149c:	22 0f       	add	r18, r18
    149e:	33 1f       	adc	r19, r19
    14a0:	22 0f       	add	r18, r18
    14a2:	33 1f       	adc	r19, r19
    14a4:	22 0f       	add	r18, r18
    14a6:	33 1f       	adc	r19, r19
    14a8:	82 0f       	add	r24, r18
    14aa:	93 1f       	adc	r25, r19
    14ac:	b8 01       	movw	r22, r16
    14ae:	87 59       	subi	r24, 0x97	; 151
    14b0:	9a 4f       	sbci	r25, 0xFA	; 250
    14b2:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInsertEnd>
    14b6:	9e 89       	ldd	r25, Y+22	; 0x16
    14b8:	e0 91 96 05 	lds	r30, 0x0596	; 0x800596 <pxCurrentTCB>
    14bc:	f0 91 97 05 	lds	r31, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    14c0:	86 89       	ldd	r24, Z+22	; 0x16
    14c2:	98 17       	cp	r25, r24
    14c4:	30 f0       	brcs	.+12     	; 0x14d2 <xTaskResumeAll+0x92>
    14c6:	81 e0       	ldi	r24, 0x01	; 1
    14c8:	80 93 30 05 	sts	0x0530, r24	; 0x800530 <xYieldPending>
    14cc:	02 c0       	rjmp	.+4      	; 0x14d2 <xTaskResumeAll+0x92>
    14ce:	c0 e0       	ldi	r28, 0x00	; 0
    14d0:	d0 e0       	ldi	r29, 0x00	; 0
    14d2:	80 91 4a 05 	lds	r24, 0x054A	; 0x80054a <xPendingReadyList>
    14d6:	81 11       	cpse	r24, r1
    14d8:	c8 cf       	rjmp	.-112    	; 0x146a <xTaskResumeAll+0x2a>
    14da:	cd 2b       	or	r28, r29
    14dc:	11 f0       	breq	.+4      	; 0x14e2 <xTaskResumeAll+0xa2>
    14de:	0e 94 0f 07 	call	0xe1e	; 0xe1e <prvResetNextTaskUnblockTime>
    14e2:	c0 91 31 05 	lds	r28, 0x0531	; 0x800531 <uxPendedTicks>
    14e6:	cc 23       	and	r28, r28
    14e8:	59 f0       	breq	.+22     	; 0x1500 <xTaskResumeAll+0xc0>
    14ea:	0e 94 66 09 	call	0x12cc	; 0x12cc <xTaskIncrementTick>
    14ee:	88 23       	and	r24, r24
    14f0:	19 f0       	breq	.+6      	; 0x14f8 <xTaskResumeAll+0xb8>
    14f2:	81 e0       	ldi	r24, 0x01	; 1
    14f4:	80 93 30 05 	sts	0x0530, r24	; 0x800530 <xYieldPending>
    14f8:	c1 50       	subi	r28, 0x01	; 1
    14fa:	b9 f7       	brne	.-18     	; 0x14ea <xTaskResumeAll+0xaa>
    14fc:	10 92 31 05 	sts	0x0531, r1	; 0x800531 <uxPendedTicks>
    1500:	80 91 30 05 	lds	r24, 0x0530	; 0x800530 <xYieldPending>
    1504:	88 23       	and	r24, r24
    1506:	31 f0       	breq	.+12     	; 0x1514 <xTaskResumeAll+0xd4>
    1508:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
    150c:	81 e0       	ldi	r24, 0x01	; 1
    150e:	03 c0       	rjmp	.+6      	; 0x1516 <xTaskResumeAll+0xd6>
    1510:	80 e0       	ldi	r24, 0x00	; 0
    1512:	01 c0       	rjmp	.+2      	; 0x1516 <xTaskResumeAll+0xd6>
    1514:	80 e0       	ldi	r24, 0x00	; 0
    1516:	0f 90       	pop	r0
    1518:	0f be       	out	0x3f, r0	; 63
    151a:	df 91       	pop	r29
    151c:	cf 91       	pop	r28
    151e:	1f 91       	pop	r17
    1520:	0f 91       	pop	r16
    1522:	08 95       	ret

00001524 <vTaskDelay>:
    1524:	cf 93       	push	r28
    1526:	df 93       	push	r29
    1528:	ec 01       	movw	r28, r24
    152a:	89 2b       	or	r24, r25
    152c:	49 f0       	breq	.+18     	; 0x1540 <vTaskDelay+0x1c>
    152e:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vTaskSuspendAll>
    1532:	60 e0       	ldi	r22, 0x00	; 0
    1534:	ce 01       	movw	r24, r28
    1536:	0e 94 39 08 	call	0x1072	; 0x1072 <prvAddCurrentTaskToDelayedList>
    153a:	0e 94 20 0a 	call	0x1440	; 0x1440 <xTaskResumeAll>
    153e:	01 c0       	rjmp	.+2      	; 0x1542 <vTaskDelay+0x1e>
    1540:	80 e0       	ldi	r24, 0x00	; 0
    1542:	81 11       	cpse	r24, r1
    1544:	02 c0       	rjmp	.+4      	; 0x154a <vTaskDelay+0x26>
    1546:	0e 94 b9 03 	call	0x772	; 0x772 <vPortYield>
    154a:	df 91       	pop	r29
    154c:	cf 91       	pop	r28
    154e:	08 95       	ret

00001550 <prvCheckTasksWaitingTermination>:
    1550:	cf 93       	push	r28
    1552:	df 93       	push	r29
    1554:	24 c0       	rjmp	.+72     	; 0x159e <prvCheckTasksWaitingTermination+0x4e>
    1556:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vTaskSuspendAll>
    155a:	c0 91 41 05 	lds	r28, 0x0541	; 0x800541 <xTasksWaitingTermination>
    155e:	0e 94 20 0a 	call	0x1440	; 0x1440 <xTaskResumeAll>
    1562:	cc 23       	and	r28, r28
    1564:	e1 f0       	breq	.+56     	; 0x159e <prvCheckTasksWaitingTermination+0x4e>
    1566:	0f b6       	in	r0, 0x3f	; 63
    1568:	f8 94       	cli
    156a:	0f 92       	push	r0
    156c:	e0 91 46 05 	lds	r30, 0x0546	; 0x800546 <xTasksWaitingTermination+0x5>
    1570:	f0 91 47 05 	lds	r31, 0x0547	; 0x800547 <xTasksWaitingTermination+0x6>
    1574:	c6 81       	ldd	r28, Z+6	; 0x06
    1576:	d7 81       	ldd	r29, Z+7	; 0x07
    1578:	ce 01       	movw	r24, r28
    157a:	02 96       	adiw	r24, 0x02	; 2
    157c:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    1580:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <uxCurrentNumberOfTasks>
    1584:	81 50       	subi	r24, 0x01	; 1
    1586:	80 93 36 05 	sts	0x0536, r24	; 0x800536 <uxCurrentNumberOfTasks>
    158a:	80 91 40 05 	lds	r24, 0x0540	; 0x800540 <uxDeletedTasksWaitingCleanUp>
    158e:	81 50       	subi	r24, 0x01	; 1
    1590:	80 93 40 05 	sts	0x0540, r24	; 0x800540 <uxDeletedTasksWaitingCleanUp>
    1594:	0f 90       	pop	r0
    1596:	0f be       	out	0x3f, r0	; 63
    1598:	ce 01       	movw	r24, r28
    159a:	0e 94 2e 07 	call	0xe5c	; 0xe5c <prvDeleteTCB>
    159e:	80 91 40 05 	lds	r24, 0x0540	; 0x800540 <uxDeletedTasksWaitingCleanUp>
    15a2:	81 11       	cpse	r24, r1
    15a4:	d8 cf       	rjmp	.-80     	; 0x1556 <prvCheckTasksWaitingTermination+0x6>
    15a6:	df 91       	pop	r29
    15a8:	cf 91       	pop	r28
    15aa:	08 95       	ret

000015ac <prvIdleTask>:
    15ac:	0e 94 a8 0a 	call	0x1550	; 0x1550 <prvCheckTasksWaitingTermination>
    15b0:	fd cf       	rjmp	.-6      	; 0x15ac <prvIdleTask>

000015b2 <vTaskSwitchContext>:
    15b2:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <uxSchedulerSuspended>
    15b6:	88 23       	and	r24, r24
    15b8:	21 f0       	breq	.+8      	; 0x15c2 <vTaskSwitchContext+0x10>
    15ba:	81 e0       	ldi	r24, 0x01	; 1
    15bc:	80 93 30 05 	sts	0x0530, r24	; 0x800530 <xYieldPending>
    15c0:	08 95       	ret
    15c2:	10 92 30 05 	sts	0x0530, r1	; 0x800530 <xYieldPending>
    15c6:	20 91 33 05 	lds	r18, 0x0533	; 0x800533 <uxTopReadyPriority>
    15ca:	01 c0       	rjmp	.+2      	; 0x15ce <vTaskSwitchContext+0x1c>
    15cc:	21 50       	subi	r18, 0x01	; 1
    15ce:	82 2f       	mov	r24, r18
    15d0:	90 e0       	ldi	r25, 0x00	; 0
    15d2:	fc 01       	movw	r30, r24
    15d4:	ee 0f       	add	r30, r30
    15d6:	ff 1f       	adc	r31, r31
    15d8:	ee 0f       	add	r30, r30
    15da:	ff 1f       	adc	r31, r31
    15dc:	ee 0f       	add	r30, r30
    15de:	ff 1f       	adc	r31, r31
    15e0:	e8 0f       	add	r30, r24
    15e2:	f9 1f       	adc	r31, r25
    15e4:	e7 59       	subi	r30, 0x97	; 151
    15e6:	fa 4f       	sbci	r31, 0xFA	; 250
    15e8:	30 81       	ld	r19, Z
    15ea:	33 23       	and	r19, r19
    15ec:	79 f3       	breq	.-34     	; 0x15cc <vTaskSwitchContext+0x1a>
    15ee:	ac 01       	movw	r20, r24
    15f0:	44 0f       	add	r20, r20
    15f2:	55 1f       	adc	r21, r21
    15f4:	44 0f       	add	r20, r20
    15f6:	55 1f       	adc	r21, r21
    15f8:	44 0f       	add	r20, r20
    15fa:	55 1f       	adc	r21, r21
    15fc:	48 0f       	add	r20, r24
    15fe:	59 1f       	adc	r21, r25
    1600:	df 01       	movw	r26, r30
    1602:	01 80       	ldd	r0, Z+1	; 0x01
    1604:	f2 81       	ldd	r31, Z+2	; 0x02
    1606:	e0 2d       	mov	r30, r0
    1608:	02 80       	ldd	r0, Z+2	; 0x02
    160a:	f3 81       	ldd	r31, Z+3	; 0x03
    160c:	e0 2d       	mov	r30, r0
    160e:	12 96       	adiw	r26, 0x02	; 2
    1610:	fc 93       	st	X, r31
    1612:	ee 93       	st	-X, r30
    1614:	11 97       	sbiw	r26, 0x01	; 1
    1616:	44 59       	subi	r20, 0x94	; 148
    1618:	5a 4f       	sbci	r21, 0xFA	; 250
    161a:	e4 17       	cp	r30, r20
    161c:	f5 07       	cpc	r31, r21
    161e:	29 f4       	brne	.+10     	; 0x162a <vTaskSwitchContext+0x78>
    1620:	42 81       	ldd	r20, Z+2	; 0x02
    1622:	53 81       	ldd	r21, Z+3	; 0x03
    1624:	fd 01       	movw	r30, r26
    1626:	52 83       	std	Z+2, r21	; 0x02
    1628:	41 83       	std	Z+1, r20	; 0x01
    162a:	fc 01       	movw	r30, r24
    162c:	ee 0f       	add	r30, r30
    162e:	ff 1f       	adc	r31, r31
    1630:	ee 0f       	add	r30, r30
    1632:	ff 1f       	adc	r31, r31
    1634:	ee 0f       	add	r30, r30
    1636:	ff 1f       	adc	r31, r31
    1638:	8e 0f       	add	r24, r30
    163a:	9f 1f       	adc	r25, r31
    163c:	fc 01       	movw	r30, r24
    163e:	e7 59       	subi	r30, 0x97	; 151
    1640:	fa 4f       	sbci	r31, 0xFA	; 250
    1642:	01 80       	ldd	r0, Z+1	; 0x01
    1644:	f2 81       	ldd	r31, Z+2	; 0x02
    1646:	e0 2d       	mov	r30, r0
    1648:	86 81       	ldd	r24, Z+6	; 0x06
    164a:	97 81       	ldd	r25, Z+7	; 0x07
    164c:	90 93 97 05 	sts	0x0597, r25	; 0x800597 <pxCurrentTCB+0x1>
    1650:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <pxCurrentTCB>
    1654:	20 93 33 05 	sts	0x0533, r18	; 0x800533 <uxTopReadyPriority>
    1658:	08 95       	ret

0000165a <vTaskPlaceOnEventList>:
    165a:	cf 93       	push	r28
    165c:	df 93       	push	r29
    165e:	eb 01       	movw	r28, r22
    1660:	60 91 96 05 	lds	r22, 0x0596	; 0x800596 <pxCurrentTCB>
    1664:	70 91 97 05 	lds	r23, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    1668:	64 5f       	subi	r22, 0xF4	; 244
    166a:	7f 4f       	sbci	r23, 0xFF	; 255
    166c:	0e 94 be 02 	call	0x57c	; 0x57c <vListInsert>
    1670:	61 e0       	ldi	r22, 0x01	; 1
    1672:	ce 01       	movw	r24, r28
    1674:	0e 94 39 08 	call	0x1072	; 0x1072 <prvAddCurrentTaskToDelayedList>
    1678:	df 91       	pop	r29
    167a:	cf 91       	pop	r28
    167c:	08 95       	ret

0000167e <xTaskRemoveFromEventList>:
    167e:	0f 93       	push	r16
    1680:	1f 93       	push	r17
    1682:	cf 93       	push	r28
    1684:	df 93       	push	r29
    1686:	dc 01       	movw	r26, r24
    1688:	15 96       	adiw	r26, 0x05	; 5
    168a:	ed 91       	ld	r30, X+
    168c:	fc 91       	ld	r31, X
    168e:	16 97       	sbiw	r26, 0x06	; 6
    1690:	c6 81       	ldd	r28, Z+6	; 0x06
    1692:	d7 81       	ldd	r29, Z+7	; 0x07
    1694:	8e 01       	movw	r16, r28
    1696:	04 5f       	subi	r16, 0xF4	; 244
    1698:	1f 4f       	sbci	r17, 0xFF	; 255
    169a:	c8 01       	movw	r24, r16
    169c:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    16a0:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <uxSchedulerSuspended>
    16a4:	81 11       	cpse	r24, r1
    16a6:	1c c0       	rjmp	.+56     	; 0x16e0 <xTaskRemoveFromEventList+0x62>
    16a8:	0a 50       	subi	r16, 0x0A	; 10
    16aa:	11 09       	sbc	r17, r1
    16ac:	c8 01       	movw	r24, r16
    16ae:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    16b2:	8e 89       	ldd	r24, Y+22	; 0x16
    16b4:	90 91 33 05 	lds	r25, 0x0533	; 0x800533 <uxTopReadyPriority>
    16b8:	98 17       	cp	r25, r24
    16ba:	10 f4       	brcc	.+4      	; 0x16c0 <xTaskRemoveFromEventList+0x42>
    16bc:	80 93 33 05 	sts	0x0533, r24	; 0x800533 <uxTopReadyPriority>
    16c0:	90 e0       	ldi	r25, 0x00	; 0
    16c2:	9c 01       	movw	r18, r24
    16c4:	22 0f       	add	r18, r18
    16c6:	33 1f       	adc	r19, r19
    16c8:	22 0f       	add	r18, r18
    16ca:	33 1f       	adc	r19, r19
    16cc:	22 0f       	add	r18, r18
    16ce:	33 1f       	adc	r19, r19
    16d0:	82 0f       	add	r24, r18
    16d2:	93 1f       	adc	r25, r19
    16d4:	b8 01       	movw	r22, r16
    16d6:	87 59       	subi	r24, 0x97	; 151
    16d8:	9a 4f       	sbci	r25, 0xFA	; 250
    16da:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInsertEnd>
    16de:	05 c0       	rjmp	.+10     	; 0x16ea <xTaskRemoveFromEventList+0x6c>
    16e0:	b8 01       	movw	r22, r16
    16e2:	8a e4       	ldi	r24, 0x4A	; 74
    16e4:	95 e0       	ldi	r25, 0x05	; 5
    16e6:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInsertEnd>
    16ea:	9e 89       	ldd	r25, Y+22	; 0x16
    16ec:	e0 91 96 05 	lds	r30, 0x0596	; 0x800596 <pxCurrentTCB>
    16f0:	f0 91 97 05 	lds	r31, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    16f4:	86 89       	ldd	r24, Z+22	; 0x16
    16f6:	89 17       	cp	r24, r25
    16f8:	20 f4       	brcc	.+8      	; 0x1702 <xTaskRemoveFromEventList+0x84>
    16fa:	81 e0       	ldi	r24, 0x01	; 1
    16fc:	80 93 30 05 	sts	0x0530, r24	; 0x800530 <xYieldPending>
    1700:	01 c0       	rjmp	.+2      	; 0x1704 <xTaskRemoveFromEventList+0x86>
    1702:	80 e0       	ldi	r24, 0x00	; 0
    1704:	df 91       	pop	r29
    1706:	cf 91       	pop	r28
    1708:	1f 91       	pop	r17
    170a:	0f 91       	pop	r16
    170c:	08 95       	ret

0000170e <vTaskSetTimeOutState>:
    170e:	20 91 2f 05 	lds	r18, 0x052F	; 0x80052f <xNumOfOverflows>
    1712:	fc 01       	movw	r30, r24
    1714:	20 83       	st	Z, r18
    1716:	20 91 34 05 	lds	r18, 0x0534	; 0x800534 <xTickCount>
    171a:	30 91 35 05 	lds	r19, 0x0535	; 0x800535 <xTickCount+0x1>
    171e:	32 83       	std	Z+2, r19	; 0x02
    1720:	21 83       	std	Z+1, r18	; 0x01
    1722:	08 95       	ret

00001724 <xTaskCheckForTimeOut>:
    1724:	0f b6       	in	r0, 0x3f	; 63
    1726:	f8 94       	cli
    1728:	0f 92       	push	r0
    172a:	40 91 34 05 	lds	r20, 0x0534	; 0x800534 <xTickCount>
    172e:	50 91 35 05 	lds	r21, 0x0535	; 0x800535 <xTickCount+0x1>
    1732:	db 01       	movw	r26, r22
    1734:	2d 91       	ld	r18, X+
    1736:	3c 91       	ld	r19, X
    1738:	2f 3f       	cpi	r18, 0xFF	; 255
    173a:	bf ef       	ldi	r27, 0xFF	; 255
    173c:	3b 07       	cpc	r19, r27
    173e:	19 f1       	breq	.+70     	; 0x1786 <xTaskCheckForTimeOut+0x62>
    1740:	dc 01       	movw	r26, r24
    1742:	fc 91       	ld	r31, X
    1744:	e0 91 2f 05 	lds	r30, 0x052F	; 0x80052f <xNumOfOverflows>
    1748:	fe 17       	cp	r31, r30
    174a:	39 f0       	breq	.+14     	; 0x175a <xTaskCheckForTimeOut+0x36>
    174c:	11 96       	adiw	r26, 0x01	; 1
    174e:	ed 91       	ld	r30, X+
    1750:	fc 91       	ld	r31, X
    1752:	12 97       	sbiw	r26, 0x02	; 2
    1754:	4e 17       	cp	r20, r30
    1756:	5f 07       	cpc	r21, r31
    1758:	c0 f4       	brcc	.+48     	; 0x178a <xTaskCheckForTimeOut+0x66>
    175a:	dc 01       	movw	r26, r24
    175c:	11 96       	adiw	r26, 0x01	; 1
    175e:	ed 91       	ld	r30, X+
    1760:	fc 91       	ld	r31, X
    1762:	12 97       	sbiw	r26, 0x02	; 2
    1764:	da 01       	movw	r26, r20
    1766:	ae 1b       	sub	r26, r30
    1768:	bf 0b       	sbc	r27, r31
    176a:	a2 17       	cp	r26, r18
    176c:	b3 07       	cpc	r27, r19
    176e:	78 f4       	brcc	.+30     	; 0x178e <xTaskCheckForTimeOut+0x6a>
    1770:	db 01       	movw	r26, r22
    1772:	e4 1b       	sub	r30, r20
    1774:	f5 0b       	sbc	r31, r21
    1776:	2e 0f       	add	r18, r30
    1778:	3f 1f       	adc	r19, r31
    177a:	2d 93       	st	X+, r18
    177c:	3c 93       	st	X, r19
    177e:	0e 94 87 0b 	call	0x170e	; 0x170e <vTaskSetTimeOutState>
    1782:	80 e0       	ldi	r24, 0x00	; 0
    1784:	05 c0       	rjmp	.+10     	; 0x1790 <xTaskCheckForTimeOut+0x6c>
    1786:	80 e0       	ldi	r24, 0x00	; 0
    1788:	03 c0       	rjmp	.+6      	; 0x1790 <xTaskCheckForTimeOut+0x6c>
    178a:	81 e0       	ldi	r24, 0x01	; 1
    178c:	01 c0       	rjmp	.+2      	; 0x1790 <xTaskCheckForTimeOut+0x6c>
    178e:	81 e0       	ldi	r24, 0x01	; 1
    1790:	0f 90       	pop	r0
    1792:	0f be       	out	0x3f, r0	; 63
    1794:	08 95       	ret

00001796 <vTaskMissedYield>:
    1796:	81 e0       	ldi	r24, 0x01	; 1
    1798:	80 93 30 05 	sts	0x0530, r24	; 0x800530 <xYieldPending>
    179c:	08 95       	ret

0000179e <vTaskPriorityInherit>:
    179e:	0f 93       	push	r16
    17a0:	1f 93       	push	r17
    17a2:	cf 93       	push	r28
    17a4:	df 93       	push	r29
    17a6:	fc 01       	movw	r30, r24
    17a8:	89 2b       	or	r24, r25
    17aa:	09 f4       	brne	.+2      	; 0x17ae <vTaskPriorityInherit+0x10>
    17ac:	55 c0       	rjmp	.+170    	; 0x1858 <vTaskPriorityInherit+0xba>
    17ae:	26 89       	ldd	r18, Z+22	; 0x16
    17b0:	a0 91 96 05 	lds	r26, 0x0596	; 0x800596 <pxCurrentTCB>
    17b4:	b0 91 97 05 	lds	r27, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    17b8:	56 96       	adiw	r26, 0x16	; 22
    17ba:	8c 91       	ld	r24, X
    17bc:	28 17       	cp	r18, r24
    17be:	08 f0       	brcs	.+2      	; 0x17c2 <vTaskPriorityInherit+0x24>
    17c0:	4b c0       	rjmp	.+150    	; 0x1858 <vTaskPriorityInherit+0xba>
    17c2:	84 85       	ldd	r24, Z+12	; 0x0c
    17c4:	95 85       	ldd	r25, Z+13	; 0x0d
    17c6:	99 23       	and	r25, r25
    17c8:	64 f0       	brlt	.+24     	; 0x17e2 <vTaskPriorityInherit+0x44>
    17ca:	a0 91 96 05 	lds	r26, 0x0596	; 0x800596 <pxCurrentTCB>
    17ce:	b0 91 97 05 	lds	r27, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    17d2:	56 96       	adiw	r26, 0x16	; 22
    17d4:	3c 91       	ld	r19, X
    17d6:	85 e0       	ldi	r24, 0x05	; 5
    17d8:	90 e0       	ldi	r25, 0x00	; 0
    17da:	83 1b       	sub	r24, r19
    17dc:	91 09       	sbc	r25, r1
    17de:	95 87       	std	Z+13, r25	; 0x0d
    17e0:	84 87       	std	Z+12, r24	; 0x0c
    17e2:	82 85       	ldd	r24, Z+10	; 0x0a
    17e4:	93 85       	ldd	r25, Z+11	; 0x0b
    17e6:	30 e0       	ldi	r19, 0x00	; 0
    17e8:	a9 01       	movw	r20, r18
    17ea:	44 0f       	add	r20, r20
    17ec:	55 1f       	adc	r21, r21
    17ee:	44 0f       	add	r20, r20
    17f0:	55 1f       	adc	r21, r21
    17f2:	44 0f       	add	r20, r20
    17f4:	55 1f       	adc	r21, r21
    17f6:	24 0f       	add	r18, r20
    17f8:	35 1f       	adc	r19, r21
    17fa:	27 59       	subi	r18, 0x97	; 151
    17fc:	3a 4f       	sbci	r19, 0xFA	; 250
    17fe:	82 17       	cp	r24, r18
    1800:	93 07       	cpc	r25, r19
    1802:	19 f5       	brne	.+70     	; 0x184a <vTaskPriorityInherit+0xac>
    1804:	8f 01       	movw	r16, r30
    1806:	ef 01       	movw	r28, r30
    1808:	22 96       	adiw	r28, 0x02	; 2
    180a:	ce 01       	movw	r24, r28
    180c:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    1810:	e0 91 96 05 	lds	r30, 0x0596	; 0x800596 <pxCurrentTCB>
    1814:	f0 91 97 05 	lds	r31, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    1818:	86 89       	ldd	r24, Z+22	; 0x16
    181a:	f8 01       	movw	r30, r16
    181c:	86 8b       	std	Z+22, r24	; 0x16
    181e:	90 91 33 05 	lds	r25, 0x0533	; 0x800533 <uxTopReadyPriority>
    1822:	98 17       	cp	r25, r24
    1824:	10 f4       	brcc	.+4      	; 0x182a <vTaskPriorityInherit+0x8c>
    1826:	80 93 33 05 	sts	0x0533, r24	; 0x800533 <uxTopReadyPriority>
    182a:	90 e0       	ldi	r25, 0x00	; 0
    182c:	9c 01       	movw	r18, r24
    182e:	22 0f       	add	r18, r18
    1830:	33 1f       	adc	r19, r19
    1832:	22 0f       	add	r18, r18
    1834:	33 1f       	adc	r19, r19
    1836:	22 0f       	add	r18, r18
    1838:	33 1f       	adc	r19, r19
    183a:	82 0f       	add	r24, r18
    183c:	93 1f       	adc	r25, r19
    183e:	be 01       	movw	r22, r28
    1840:	87 59       	subi	r24, 0x97	; 151
    1842:	9a 4f       	sbci	r25, 0xFA	; 250
    1844:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInsertEnd>
    1848:	07 c0       	rjmp	.+14     	; 0x1858 <vTaskPriorityInherit+0xba>
    184a:	a0 91 96 05 	lds	r26, 0x0596	; 0x800596 <pxCurrentTCB>
    184e:	b0 91 97 05 	lds	r27, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    1852:	56 96       	adiw	r26, 0x16	; 22
    1854:	8c 91       	ld	r24, X
    1856:	86 8b       	std	Z+22, r24	; 0x16
    1858:	df 91       	pop	r29
    185a:	cf 91       	pop	r28
    185c:	1f 91       	pop	r17
    185e:	0f 91       	pop	r16
    1860:	08 95       	ret

00001862 <xTaskPriorityDisinherit>:
    1862:	0f 93       	push	r16
    1864:	1f 93       	push	r17
    1866:	cf 93       	push	r28
    1868:	df 93       	push	r29
    186a:	fc 01       	movw	r30, r24
    186c:	89 2b       	or	r24, r25
    186e:	79 f1       	breq	.+94     	; 0x18ce <xTaskPriorityDisinherit+0x6c>
    1870:	82 a1       	ldd	r24, Z+34	; 0x22
    1872:	81 50       	subi	r24, 0x01	; 1
    1874:	82 a3       	std	Z+34, r24	; 0x22
    1876:	26 89       	ldd	r18, Z+22	; 0x16
    1878:	91 a1       	ldd	r25, Z+33	; 0x21
    187a:	29 17       	cp	r18, r25
    187c:	51 f1       	breq	.+84     	; 0x18d2 <xTaskPriorityDisinherit+0x70>
    187e:	81 11       	cpse	r24, r1
    1880:	2a c0       	rjmp	.+84     	; 0x18d6 <xTaskPriorityDisinherit+0x74>
    1882:	ef 01       	movw	r28, r30
    1884:	8f 01       	movw	r16, r30
    1886:	0e 5f       	subi	r16, 0xFE	; 254
    1888:	1f 4f       	sbci	r17, 0xFF	; 255
    188a:	c8 01       	movw	r24, r16
    188c:	0e 94 ef 02 	call	0x5de	; 0x5de <uxListRemove>
    1890:	89 a1       	ldd	r24, Y+33	; 0x21
    1892:	8e 8b       	std	Y+22, r24	; 0x16
    1894:	25 e0       	ldi	r18, 0x05	; 5
    1896:	30 e0       	ldi	r19, 0x00	; 0
    1898:	28 1b       	sub	r18, r24
    189a:	31 09       	sbc	r19, r1
    189c:	3d 87       	std	Y+13, r19	; 0x0d
    189e:	2c 87       	std	Y+12, r18	; 0x0c
    18a0:	90 91 33 05 	lds	r25, 0x0533	; 0x800533 <uxTopReadyPriority>
    18a4:	98 17       	cp	r25, r24
    18a6:	10 f4       	brcc	.+4      	; 0x18ac <xTaskPriorityDisinherit+0x4a>
    18a8:	80 93 33 05 	sts	0x0533, r24	; 0x800533 <uxTopReadyPriority>
    18ac:	90 e0       	ldi	r25, 0x00	; 0
    18ae:	9c 01       	movw	r18, r24
    18b0:	22 0f       	add	r18, r18
    18b2:	33 1f       	adc	r19, r19
    18b4:	22 0f       	add	r18, r18
    18b6:	33 1f       	adc	r19, r19
    18b8:	22 0f       	add	r18, r18
    18ba:	33 1f       	adc	r19, r19
    18bc:	82 0f       	add	r24, r18
    18be:	93 1f       	adc	r25, r19
    18c0:	b8 01       	movw	r22, r16
    18c2:	87 59       	subi	r24, 0x97	; 151
    18c4:	9a 4f       	sbci	r25, 0xFA	; 250
    18c6:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInsertEnd>
    18ca:	81 e0       	ldi	r24, 0x01	; 1
    18cc:	05 c0       	rjmp	.+10     	; 0x18d8 <xTaskPriorityDisinherit+0x76>
    18ce:	80 e0       	ldi	r24, 0x00	; 0
    18d0:	03 c0       	rjmp	.+6      	; 0x18d8 <xTaskPriorityDisinherit+0x76>
    18d2:	80 e0       	ldi	r24, 0x00	; 0
    18d4:	01 c0       	rjmp	.+2      	; 0x18d8 <xTaskPriorityDisinherit+0x76>
    18d6:	80 e0       	ldi	r24, 0x00	; 0
    18d8:	df 91       	pop	r29
    18da:	cf 91       	pop	r28
    18dc:	1f 91       	pop	r17
    18de:	0f 91       	pop	r16
    18e0:	08 95       	ret

000018e2 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    18e2:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <pxCurrentTCB>
    18e6:	90 91 97 05 	lds	r25, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    18ea:	89 2b       	or	r24, r25
    18ec:	39 f0       	breq	.+14     	; 0x18fc <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    18ee:	e0 91 96 05 	lds	r30, 0x0596	; 0x800596 <pxCurrentTCB>
    18f2:	f0 91 97 05 	lds	r31, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
    18f6:	82 a1       	ldd	r24, Z+34	; 0x22
    18f8:	8f 5f       	subi	r24, 0xFF	; 255
    18fa:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    18fc:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <pxCurrentTCB>
    1900:	90 91 97 05 	lds	r25, 0x0597	; 0x800597 <pxCurrentTCB+0x1>
	}
    1904:	08 95       	ret

00001906 <Buzzer_init>:
 * Returns     : None
 ***************************************************/
void Buzzer_init(void){
	/* first set the 2 pin of the buzzer to be output
	 * then connect them to login low (GND) to be off */
	DIO_voidSetPinDir(BUZZER_portID,BUZZER_positive_PinID,OUTPUT);
    1906:	41 e0       	ldi	r20, 0x01	; 1
    1908:	61 e0       	ldi	r22, 0x01	; 1
    190a:	82 e0       	ldi	r24, 0x02	; 2
    190c:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <DIO_voidSetPinDir>
	DIO_voidSetPinDir(BUZZER_portID,BUZZER_negative_PinID,OUTPUT);
    1910:	41 e0       	ldi	r20, 0x01	; 1
    1912:	62 e0       	ldi	r22, 0x02	; 2
    1914:	82 e0       	ldi	r24, 0x02	; 2
    1916:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <DIO_voidSetPinDir>

	DIO_voidSetPinVal(BUZZER_portID,BUZZER_positive_PinID,LOW);
    191a:	40 e0       	ldi	r20, 0x00	; 0
    191c:	61 e0       	ldi	r22, 0x01	; 1
    191e:	82 e0       	ldi	r24, 0x02	; 2
    1920:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
	DIO_voidSetPinVal(BUZZER_portID,BUZZER_negative_PinID,LOW);
    1924:	40 e0       	ldi	r20, 0x00	; 0
    1926:	62 e0       	ldi	r22, 0x02	; 2
    1928:	82 e0       	ldi	r24, 0x02	; 2
    192a:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
    192e:	08 95       	ret

00001930 <Buzzer_on>:
 * Argument    : None
 * Returns     : None
 ***************************************************/
void Buzzer_on(void){
	/* connect the positive terminal to +ve and the negative terminal to ground */
	DIO_voidSetPinVal(BUZZER_portID,BUZZER_positive_PinID,HIGH);
    1930:	41 e0       	ldi	r20, 0x01	; 1
    1932:	61 e0       	ldi	r22, 0x01	; 1
    1934:	82 e0       	ldi	r24, 0x02	; 2
    1936:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
	DIO_voidSetPinVal(BUZZER_portID,BUZZER_negative_PinID,LOW);
    193a:	40 e0       	ldi	r20, 0x00	; 0
    193c:	62 e0       	ldi	r22, 0x02	; 2
    193e:	82 e0       	ldi	r24, 0x02	; 2
    1940:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
    1944:	08 95       	ret

00001946 <LCD_voidSHD>:
	  LCD_voidSendData(pattern) ; 
	  
	  
	
	
}
    1946:	0f 93       	push	r16
    1948:	1f 93       	push	r17
    194a:	cf 93       	push	r28
    194c:	df 93       	push	r29
    194e:	00 d0       	rcall	.+0      	; 0x1950 <LCD_voidSHD+0xa>
    1950:	00 d0       	rcall	.+0      	; 0x1952 <LCD_voidSHD+0xc>
    1952:	cd b7       	in	r28, 0x3d	; 61
    1954:	de b7       	in	r29, 0x3e	; 62
    1956:	08 2f       	mov	r16, r24
    1958:	84 e0       	ldi	r24, 0x04	; 4
    195a:	89 83       	std	Y+1, r24	; 0x01
    195c:	85 e0       	ldi	r24, 0x05	; 5
    195e:	8a 83       	std	Y+2, r24	; 0x02
    1960:	86 e0       	ldi	r24, 0x06	; 6
    1962:	8b 83       	std	Y+3, r24	; 0x03
    1964:	87 e0       	ldi	r24, 0x07	; 7
    1966:	8c 83       	std	Y+4, r24	; 0x04
    1968:	10 e0       	ldi	r17, 0x00	; 0
    196a:	14 c0       	rjmp	.+40     	; 0x1994 <LCD_voidSHD+0x4e>
    196c:	40 2f       	mov	r20, r16
    196e:	50 e0       	ldi	r21, 0x00	; 0
    1970:	01 2e       	mov	r0, r17
    1972:	02 c0       	rjmp	.+4      	; 0x1978 <LCD_voidSHD+0x32>
    1974:	55 95       	asr	r21
    1976:	47 95       	ror	r20
    1978:	0a 94       	dec	r0
    197a:	e2 f7       	brpl	.-8      	; 0x1974 <LCD_voidSHD+0x2e>
    197c:	41 70       	andi	r20, 0x01	; 1
    197e:	e1 e0       	ldi	r30, 0x01	; 1
    1980:	f0 e0       	ldi	r31, 0x00	; 0
    1982:	ec 0f       	add	r30, r28
    1984:	fd 1f       	adc	r31, r29
    1986:	e1 0f       	add	r30, r17
    1988:	f1 1d       	adc	r31, r1
    198a:	60 81       	ld	r22, Z
    198c:	80 e0       	ldi	r24, 0x00	; 0
    198e:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
    1992:	1f 5f       	subi	r17, 0xFF	; 255
    1994:	14 30       	cpi	r17, 0x04	; 4
    1996:	50 f3       	brcs	.-44     	; 0x196c <LCD_voidSHD+0x26>
    1998:	0f 90       	pop	r0
    199a:	0f 90       	pop	r0
    199c:	0f 90       	pop	r0
    199e:	0f 90       	pop	r0
    19a0:	df 91       	pop	r29
    19a2:	cf 91       	pop	r28
    19a4:	1f 91       	pop	r17
    19a6:	0f 91       	pop	r16
    19a8:	08 95       	ret

000019aa <LCD_voidSendEnable>:
    19aa:	41 e0       	ldi	r20, 0x01	; 1
    19ac:	62 e0       	ldi	r22, 0x02	; 2
    19ae:	80 e0       	ldi	r24, 0x00	; 0
    19b0:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
    19b4:	8f e3       	ldi	r24, 0x3F	; 63
    19b6:	9f e1       	ldi	r25, 0x1F	; 31
    19b8:	01 97       	sbiw	r24, 0x01	; 1
    19ba:	f1 f7       	brne	.-4      	; 0x19b8 <LCD_voidSendEnable+0xe>
    19bc:	00 c0       	rjmp	.+0      	; 0x19be <LCD_voidSendEnable+0x14>
    19be:	00 00       	nop
    19c0:	40 e0       	ldi	r20, 0x00	; 0
    19c2:	62 e0       	ldi	r22, 0x02	; 2
    19c4:	80 e0       	ldi	r24, 0x00	; 0
    19c6:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
    19ca:	08 95       	ret

000019cc <LCD_voidSendData>:
    19cc:	cf 93       	push	r28
    19ce:	c8 2f       	mov	r28, r24
    19d0:	41 e0       	ldi	r20, 0x01	; 1
    19d2:	63 e0       	ldi	r22, 0x03	; 3
    19d4:	80 e0       	ldi	r24, 0x00	; 0
    19d6:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
    19da:	40 e0       	ldi	r20, 0x00	; 0
    19dc:	61 e0       	ldi	r22, 0x01	; 1
    19de:	80 e0       	ldi	r24, 0x00	; 0
    19e0:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
    19e4:	8c 2f       	mov	r24, r28
    19e6:	82 95       	swap	r24
    19e8:	8f 70       	andi	r24, 0x0F	; 15
    19ea:	0e 94 a3 0c 	call	0x1946	; 0x1946 <LCD_voidSHD>
    19ee:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <LCD_voidSendEnable>
    19f2:	8c 2f       	mov	r24, r28
    19f4:	0e 94 a3 0c 	call	0x1946	; 0x1946 <LCD_voidSHD>
    19f8:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <LCD_voidSendEnable>
    19fc:	cf 91       	pop	r28
    19fe:	08 95       	ret

00001a00 <LCD_voidSendCommand>:
    1a00:	cf 93       	push	r28
    1a02:	c8 2f       	mov	r28, r24
    1a04:	40 e0       	ldi	r20, 0x00	; 0
    1a06:	63 e0       	ldi	r22, 0x03	; 3
    1a08:	80 e0       	ldi	r24, 0x00	; 0
    1a0a:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
    1a0e:	40 e0       	ldi	r20, 0x00	; 0
    1a10:	61 e0       	ldi	r22, 0x01	; 1
    1a12:	80 e0       	ldi	r24, 0x00	; 0
    1a14:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
    1a18:	8c 2f       	mov	r24, r28
    1a1a:	82 95       	swap	r24
    1a1c:	8f 70       	andi	r24, 0x0F	; 15
    1a1e:	0e 94 a3 0c 	call	0x1946	; 0x1946 <LCD_voidSHD>
    1a22:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <LCD_voidSendEnable>
    1a26:	8c 2f       	mov	r24, r28
    1a28:	0e 94 a3 0c 	call	0x1946	; 0x1946 <LCD_voidSHD>
    1a2c:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <LCD_voidSendEnable>
    1a30:	cf 91       	pop	r28
    1a32:	08 95       	ret

00001a34 <LCD_voidInit>:
    1a34:	2f ef       	ldi	r18, 0xFF	; 255
    1a36:	83 ef       	ldi	r24, 0xF3	; 243
    1a38:	91 e0       	ldi	r25, 0x01	; 1
    1a3a:	21 50       	subi	r18, 0x01	; 1
    1a3c:	80 40       	sbci	r24, 0x00	; 0
    1a3e:	90 40       	sbci	r25, 0x00	; 0
    1a40:	e1 f7       	brne	.-8      	; 0x1a3a <LCD_voidInit+0x6>
    1a42:	00 c0       	rjmp	.+0      	; 0x1a44 <LCD_voidInit+0x10>
    1a44:	00 00       	nop
    1a46:	82 e0       	ldi	r24, 0x02	; 2
    1a48:	0e 94 a3 0c 	call	0x1946	; 0x1946 <LCD_voidSHD>
    1a4c:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <LCD_voidSendEnable>
    1a50:	82 e0       	ldi	r24, 0x02	; 2
    1a52:	0e 94 a3 0c 	call	0x1946	; 0x1946 <LCD_voidSHD>
    1a56:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <LCD_voidSendEnable>
    1a5a:	88 e0       	ldi	r24, 0x08	; 8
    1a5c:	0e 94 a3 0c 	call	0x1946	; 0x1946 <LCD_voidSHD>
    1a60:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <LCD_voidSendEnable>
    1a64:	8c e0       	ldi	r24, 0x0C	; 12
    1a66:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_voidSendCommand>
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_voidSendCommand>
    1a70:	08 95       	ret

00001a72 <LCD_voidSendString>:
    1a72:	0f 93       	push	r16
    1a74:	1f 93       	push	r17
    1a76:	cf 93       	push	r28
    1a78:	8c 01       	movw	r16, r24
    1a7a:	c0 e0       	ldi	r28, 0x00	; 0
    1a7c:	03 c0       	rjmp	.+6      	; 0x1a84 <LCD_voidSendString+0x12>
    1a7e:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <LCD_voidSendData>
    1a82:	cf 5f       	subi	r28, 0xFF	; 255
    1a84:	f8 01       	movw	r30, r16
    1a86:	ec 0f       	add	r30, r28
    1a88:	f1 1d       	adc	r31, r1
    1a8a:	80 81       	ld	r24, Z
    1a8c:	81 11       	cpse	r24, r1
    1a8e:	f7 cf       	rjmp	.-18     	; 0x1a7e <LCD_voidSendString+0xc>
    1a90:	cf 91       	pop	r28
    1a92:	1f 91       	pop	r17
    1a94:	0f 91       	pop	r16
    1a96:	08 95       	ret

00001a98 <LCD_voidGotoxy>:
    1a98:	90 e4       	ldi	r25, 0x40	; 64
    1a9a:	69 9f       	mul	r22, r25
    1a9c:	80 0d       	add	r24, r0
    1a9e:	11 24       	eor	r1, r1
    1aa0:	80 68       	ori	r24, 0x80	; 128
    1aa2:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LCD_voidSendCommand>
    1aa6:	08 95       	ret

00001aa8 <LCD_voidSendNumber>:
void LCD_voidSendNumber(u32 number){
    1aa8:	1f 93       	push	r17
    1aaa:	cf 93       	push	r28
    1aac:	df 93       	push	r29
    1aae:	cd b7       	in	r28, 0x3d	; 61
    1ab0:	de b7       	in	r29, 0x3e	; 62
    1ab2:	2a 97       	sbiw	r28, 0x0a	; 10
    1ab4:	0f b6       	in	r0, 0x3f	; 63
    1ab6:	f8 94       	cli
    1ab8:	de bf       	out	0x3e, r29	; 62
    1aba:	0f be       	out	0x3f, r0	; 63
    1abc:	cd bf       	out	0x3d, r28	; 61
	
	s8 i=0;
	u8 array[10] ;
	
	if(number==0){
    1abe:	61 15       	cp	r22, r1
    1ac0:	71 05       	cpc	r23, r1
    1ac2:	81 05       	cpc	r24, r1
    1ac4:	91 05       	cpc	r25, r1
    1ac6:	d1 f4       	brne	.+52     	; 0x1afc <LCD_voidSendNumber+0x54>
		
		LCD_voidSendData('0') ;
    1ac8:	80 e3       	ldi	r24, 0x30	; 48
    1aca:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <LCD_voidSendData>
    1ace:	2c c0       	rjmp	.+88     	; 0x1b28 <LCD_voidSendNumber+0x80>
		return ;
	}
	for(i=0; number!=0 ;i++){
		
		array[i]= number % 10 + 48 ;
    1ad0:	2a e0       	ldi	r18, 0x0A	; 10
    1ad2:	30 e0       	ldi	r19, 0x00	; 0
    1ad4:	40 e0       	ldi	r20, 0x00	; 0
    1ad6:	50 e0       	ldi	r21, 0x00	; 0
    1ad8:	0e 94 3b 10 	call	0x2076	; 0x2076 <__udivmodsi4>
    1adc:	e1 e0       	ldi	r30, 0x01	; 1
    1ade:	f0 e0       	ldi	r31, 0x00	; 0
    1ae0:	ec 0f       	add	r30, r28
    1ae2:	fd 1f       	adc	r31, r29
    1ae4:	e1 0f       	add	r30, r17
    1ae6:	f1 1d       	adc	r31, r1
    1ae8:	17 fd       	sbrc	r17, 7
    1aea:	fa 95       	dec	r31
    1aec:	60 5d       	subi	r22, 0xD0	; 208
    1aee:	60 83       	st	Z, r22
		number /= 10 ;
    1af0:	62 2f       	mov	r22, r18
    1af2:	73 2f       	mov	r23, r19
    1af4:	84 2f       	mov	r24, r20
    1af6:	95 2f       	mov	r25, r21
	if(number==0){
		
		LCD_voidSendData('0') ;
		return ;
	}
	for(i=0; number!=0 ;i++){
    1af8:	1f 5f       	subi	r17, 0xFF	; 255
    1afa:	01 c0       	rjmp	.+2      	; 0x1afe <LCD_voidSendNumber+0x56>
    1afc:	10 e0       	ldi	r17, 0x00	; 0
    1afe:	61 15       	cp	r22, r1
    1b00:	71 05       	cpc	r23, r1
    1b02:	81 05       	cpc	r24, r1
    1b04:	91 05       	cpc	r25, r1
    1b06:	21 f7       	brne	.-56     	; 0x1ad0 <LCD_voidSendNumber+0x28>
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
    1b08:	11 50       	subi	r17, 0x01	; 1
	while(i >= 0){
    1b0a:	0c c0       	rjmp	.+24     	; 0x1b24 <LCD_voidSendNumber+0x7c>
		
		LCD_voidSendData(array[i]) ;
    1b0c:	e1 e0       	ldi	r30, 0x01	; 1
    1b0e:	f0 e0       	ldi	r31, 0x00	; 0
    1b10:	ec 0f       	add	r30, r28
    1b12:	fd 1f       	adc	r31, r29
    1b14:	e1 0f       	add	r30, r17
    1b16:	f1 1d       	adc	r31, r1
    1b18:	17 fd       	sbrc	r17, 7
    1b1a:	fa 95       	dec	r31
    1b1c:	80 81       	ld	r24, Z
    1b1e:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <LCD_voidSendData>
		i-- ;
    1b22:	11 50       	subi	r17, 0x01	; 1
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
	while(i >= 0){
    1b24:	11 23       	and	r17, r17
    1b26:	94 f7       	brge	.-28     	; 0x1b0c <LCD_voidSendNumber+0x64>
		
		LCD_voidSendData(array[i]) ;
		i-- ;
	}
    1b28:	2a 96       	adiw	r28, 0x0a	; 10
    1b2a:	0f b6       	in	r0, 0x3f	; 63
    1b2c:	f8 94       	cli
    1b2e:	de bf       	out	0x3e, r29	; 62
    1b30:	0f be       	out	0x3f, r0	; 63
    1b32:	cd bf       	out	0x3d, r28	; 61
    1b34:	df 91       	pop	r29
    1b36:	cf 91       	pop	r28
    1b38:	1f 91       	pop	r17
    1b3a:	08 95       	ret

00001b3c <LED_voidLedOn>:
#include "../../LIB/BIT_MATH.h"
 #include "LED_interface.h"
 #include "../../MCAL/DIO/DIO_interface.h"
 
 void LED_voidLedOn( u8 copy_u8Port,u8 copy_u8Pin){
	DIO_voidSetPinVal(copy_u8Port,copy_u8Pin,HIGH);
    1b3c:	41 e0       	ldi	r20, 0x01	; 1
    1b3e:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <DIO_voidSetPinVal>
    1b42:	08 95       	ret

00001b44 <ADC_voidInit>:


void ADC_voidInit(){
	
	/*Reference Selections for ADC : AVCC with external capacitor at AREF pin*/
	 CLR_BIT(ADMUX_REG,7) ; 
    1b44:	87 b1       	in	r24, 0x07	; 7
    1b46:	8f 77       	andi	r24, 0x7F	; 127
    1b48:	87 b9       	out	0x07, r24	; 7
	 SET_BIT(ADMUX_REG,6) ; 
    1b4a:	87 b1       	in	r24, 0x07	; 7
    1b4c:	80 64       	ori	r24, 0x40	; 64
    1b4e:	87 b9       	out	0x07, r24	; 7
	 
	/*select prescaler */
	 
	 ADCSRA_REG&=0b11111000 ; 
    1b50:	86 b1       	in	r24, 0x06	; 6
    1b52:	88 7f       	andi	r24, 0xF8	; 248
    1b54:	86 b9       	out	0x06, r24	; 6
	 ADCSRA_REG|=ADC_PRESCALER ; 
    1b56:	86 b1       	in	r24, 0x06	; 6
    1b58:	87 60       	ori	r24, 0x07	; 7
    1b5a:	86 b9       	out	0x06, r24	; 6
	
	
	/* ENABLE ADC */
	
	SET_BIT(ADCSRA_REG,7) ; 
    1b5c:	86 b1       	in	r24, 0x06	; 6
    1b5e:	80 68       	ori	r24, 0x80	; 128
    1b60:	86 b9       	out	0x06, r24	; 6
    1b62:	08 95       	ret

00001b64 <ADC_u16ReadChannel>:
}

u16 ADC_u16ReadChannel(u8 copy_u8channel){
	
	  /* select channel */
	  ADMUX_REG &=0b11100000 ; 
    1b64:	97 b1       	in	r25, 0x07	; 7
    1b66:	90 7e       	andi	r25, 0xE0	; 224
    1b68:	97 b9       	out	0x07, r25	; 7
	  ADMUX_REG |=copy_u8channel ; 
    1b6a:	97 b1       	in	r25, 0x07	; 7
    1b6c:	89 2b       	or	r24, r25
    1b6e:	87 b9       	out	0x07, r24	; 7
	  /* start conversion */
	  SET_BIT(ADCSRA_REG,6) ; 
    1b70:	86 b1       	in	r24, 0x06	; 6
    1b72:	80 64       	ori	r24, 0x40	; 64
    1b74:	86 b9       	out	0x06, r24	; 6
	  
	  while(GET_BIT(ADCSRA_REG,4)==0) ; 
    1b76:	34 9b       	sbis	0x06, 4	; 6
    1b78:	fe cf       	rjmp	.-4      	; 0x1b76 <ADC_u16ReadChannel+0x12>
	  
	  SET_BIT(ADCSRA_REG,4) ; // CLR FLAG 
    1b7a:	86 b1       	in	r24, 0x06	; 6
    1b7c:	80 61       	ori	r24, 0x10	; 16
    1b7e:	86 b9       	out	0x06, r24	; 6
	  
	  return  ADC_REG ; 
    1b80:	84 b1       	in	r24, 0x04	; 4
    1b82:	95 b1       	in	r25, 0x05	; 5

    1b84:	08 95       	ret

00001b86 <DIO_voidSetPinDir>:
	
	
	return Loc_u8Val ; 
	
	
}
    1b86:	42 30       	cpi	r20, 0x02	; 2
    1b88:	08 f0       	brcs	.+2      	; 0x1b8c <DIO_voidSetPinDir+0x6>
    1b8a:	6f c0       	rjmp	.+222    	; 0x1c6a <DIO_voidSetPinDir+0xe4>
    1b8c:	41 30       	cpi	r20, 0x01	; 1
    1b8e:	a1 f5       	brne	.+104    	; 0x1bf8 <DIO_voidSetPinDir+0x72>
    1b90:	81 30       	cpi	r24, 0x01	; 1
    1b92:	89 f0       	breq	.+34     	; 0x1bb6 <DIO_voidSetPinDir+0x30>
    1b94:	28 f0       	brcs	.+10     	; 0x1ba0 <DIO_voidSetPinDir+0x1a>
    1b96:	82 30       	cpi	r24, 0x02	; 2
    1b98:	c9 f0       	breq	.+50     	; 0x1bcc <DIO_voidSetPinDir+0x46>
    1b9a:	83 30       	cpi	r24, 0x03	; 3
    1b9c:	11 f1       	breq	.+68     	; 0x1be2 <DIO_voidSetPinDir+0x5c>
    1b9e:	08 95       	ret
    1ba0:	2a b3       	in	r18, 0x1a	; 26
    1ba2:	81 e0       	ldi	r24, 0x01	; 1
    1ba4:	90 e0       	ldi	r25, 0x00	; 0
    1ba6:	02 c0       	rjmp	.+4      	; 0x1bac <DIO_voidSetPinDir+0x26>
    1ba8:	88 0f       	add	r24, r24
    1baa:	99 1f       	adc	r25, r25
    1bac:	6a 95       	dec	r22
    1bae:	e2 f7       	brpl	.-8      	; 0x1ba8 <DIO_voidSetPinDir+0x22>
    1bb0:	82 2b       	or	r24, r18
    1bb2:	8a bb       	out	0x1a, r24	; 26
    1bb4:	08 95       	ret
    1bb6:	27 b3       	in	r18, 0x17	; 23
    1bb8:	81 e0       	ldi	r24, 0x01	; 1
    1bba:	90 e0       	ldi	r25, 0x00	; 0
    1bbc:	02 c0       	rjmp	.+4      	; 0x1bc2 <DIO_voidSetPinDir+0x3c>
    1bbe:	88 0f       	add	r24, r24
    1bc0:	99 1f       	adc	r25, r25
    1bc2:	6a 95       	dec	r22
    1bc4:	e2 f7       	brpl	.-8      	; 0x1bbe <DIO_voidSetPinDir+0x38>
    1bc6:	82 2b       	or	r24, r18
    1bc8:	87 bb       	out	0x17, r24	; 23
    1bca:	08 95       	ret
    1bcc:	24 b3       	in	r18, 0x14	; 20
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	02 c0       	rjmp	.+4      	; 0x1bd8 <DIO_voidSetPinDir+0x52>
    1bd4:	88 0f       	add	r24, r24
    1bd6:	99 1f       	adc	r25, r25
    1bd8:	6a 95       	dec	r22
    1bda:	e2 f7       	brpl	.-8      	; 0x1bd4 <DIO_voidSetPinDir+0x4e>
    1bdc:	82 2b       	or	r24, r18
    1bde:	84 bb       	out	0x14, r24	; 20
    1be0:	08 95       	ret
    1be2:	21 b3       	in	r18, 0x11	; 17
    1be4:	81 e0       	ldi	r24, 0x01	; 1
    1be6:	90 e0       	ldi	r25, 0x00	; 0
    1be8:	02 c0       	rjmp	.+4      	; 0x1bee <DIO_voidSetPinDir+0x68>
    1bea:	88 0f       	add	r24, r24
    1bec:	99 1f       	adc	r25, r25
    1bee:	6a 95       	dec	r22
    1bf0:	e2 f7       	brpl	.-8      	; 0x1bea <DIO_voidSetPinDir+0x64>
    1bf2:	82 2b       	or	r24, r18
    1bf4:	81 bb       	out	0x11, r24	; 17
    1bf6:	08 95       	ret
    1bf8:	41 11       	cpse	r20, r1
    1bfa:	37 c0       	rjmp	.+110    	; 0x1c6a <DIO_voidSetPinDir+0xe4>
    1bfc:	81 30       	cpi	r24, 0x01	; 1
    1bfe:	91 f0       	breq	.+36     	; 0x1c24 <DIO_voidSetPinDir+0x9e>
    1c00:	28 f0       	brcs	.+10     	; 0x1c0c <DIO_voidSetPinDir+0x86>
    1c02:	82 30       	cpi	r24, 0x02	; 2
    1c04:	d9 f0       	breq	.+54     	; 0x1c3c <DIO_voidSetPinDir+0xb6>
    1c06:	83 30       	cpi	r24, 0x03	; 3
    1c08:	29 f1       	breq	.+74     	; 0x1c54 <DIO_voidSetPinDir+0xce>
    1c0a:	08 95       	ret
    1c0c:	2a b3       	in	r18, 0x1a	; 26
    1c0e:	81 e0       	ldi	r24, 0x01	; 1
    1c10:	90 e0       	ldi	r25, 0x00	; 0
    1c12:	02 c0       	rjmp	.+4      	; 0x1c18 <DIO_voidSetPinDir+0x92>
    1c14:	88 0f       	add	r24, r24
    1c16:	99 1f       	adc	r25, r25
    1c18:	6a 95       	dec	r22
    1c1a:	e2 f7       	brpl	.-8      	; 0x1c14 <DIO_voidSetPinDir+0x8e>
    1c1c:	80 95       	com	r24
    1c1e:	82 23       	and	r24, r18
    1c20:	8a bb       	out	0x1a, r24	; 26
    1c22:	08 95       	ret
    1c24:	27 b3       	in	r18, 0x17	; 23
    1c26:	81 e0       	ldi	r24, 0x01	; 1
    1c28:	90 e0       	ldi	r25, 0x00	; 0
    1c2a:	02 c0       	rjmp	.+4      	; 0x1c30 <DIO_voidSetPinDir+0xaa>
    1c2c:	88 0f       	add	r24, r24
    1c2e:	99 1f       	adc	r25, r25
    1c30:	6a 95       	dec	r22
    1c32:	e2 f7       	brpl	.-8      	; 0x1c2c <DIO_voidSetPinDir+0xa6>
    1c34:	80 95       	com	r24
    1c36:	82 23       	and	r24, r18
    1c38:	87 bb       	out	0x17, r24	; 23
    1c3a:	08 95       	ret
    1c3c:	24 b3       	in	r18, 0x14	; 20
    1c3e:	81 e0       	ldi	r24, 0x01	; 1
    1c40:	90 e0       	ldi	r25, 0x00	; 0
    1c42:	02 c0       	rjmp	.+4      	; 0x1c48 <DIO_voidSetPinDir+0xc2>
    1c44:	88 0f       	add	r24, r24
    1c46:	99 1f       	adc	r25, r25
    1c48:	6a 95       	dec	r22
    1c4a:	e2 f7       	brpl	.-8      	; 0x1c44 <DIO_voidSetPinDir+0xbe>
    1c4c:	80 95       	com	r24
    1c4e:	82 23       	and	r24, r18
    1c50:	84 bb       	out	0x14, r24	; 20
    1c52:	08 95       	ret
    1c54:	21 b3       	in	r18, 0x11	; 17
    1c56:	81 e0       	ldi	r24, 0x01	; 1
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	02 c0       	rjmp	.+4      	; 0x1c60 <DIO_voidSetPinDir+0xda>
    1c5c:	88 0f       	add	r24, r24
    1c5e:	99 1f       	adc	r25, r25
    1c60:	6a 95       	dec	r22
    1c62:	e2 f7       	brpl	.-8      	; 0x1c5c <DIO_voidSetPinDir+0xd6>
    1c64:	80 95       	com	r24
    1c66:	82 23       	and	r24, r18
    1c68:	81 bb       	out	0x11, r24	; 17
    1c6a:	08 95       	ret

00001c6c <DIO_voidSetPinVal>:
    1c6c:	42 30       	cpi	r20, 0x02	; 2
    1c6e:	08 f0       	brcs	.+2      	; 0x1c72 <DIO_voidSetPinVal+0x6>
    1c70:	6f c0       	rjmp	.+222    	; 0x1d50 <DIO_voidSetPinVal+0xe4>
    1c72:	41 30       	cpi	r20, 0x01	; 1
    1c74:	a1 f5       	brne	.+104    	; 0x1cde <DIO_voidSetPinVal+0x72>
    1c76:	81 30       	cpi	r24, 0x01	; 1
    1c78:	89 f0       	breq	.+34     	; 0x1c9c <DIO_voidSetPinVal+0x30>
    1c7a:	28 f0       	brcs	.+10     	; 0x1c86 <DIO_voidSetPinVal+0x1a>
    1c7c:	82 30       	cpi	r24, 0x02	; 2
    1c7e:	c9 f0       	breq	.+50     	; 0x1cb2 <DIO_voidSetPinVal+0x46>
    1c80:	83 30       	cpi	r24, 0x03	; 3
    1c82:	11 f1       	breq	.+68     	; 0x1cc8 <DIO_voidSetPinVal+0x5c>
    1c84:	08 95       	ret
    1c86:	2b b3       	in	r18, 0x1b	; 27
    1c88:	81 e0       	ldi	r24, 0x01	; 1
    1c8a:	90 e0       	ldi	r25, 0x00	; 0
    1c8c:	02 c0       	rjmp	.+4      	; 0x1c92 <DIO_voidSetPinVal+0x26>
    1c8e:	88 0f       	add	r24, r24
    1c90:	99 1f       	adc	r25, r25
    1c92:	6a 95       	dec	r22
    1c94:	e2 f7       	brpl	.-8      	; 0x1c8e <DIO_voidSetPinVal+0x22>
    1c96:	82 2b       	or	r24, r18
    1c98:	8b bb       	out	0x1b, r24	; 27
    1c9a:	08 95       	ret
    1c9c:	28 b3       	in	r18, 0x18	; 24
    1c9e:	81 e0       	ldi	r24, 0x01	; 1
    1ca0:	90 e0       	ldi	r25, 0x00	; 0
    1ca2:	02 c0       	rjmp	.+4      	; 0x1ca8 <DIO_voidSetPinVal+0x3c>
    1ca4:	88 0f       	add	r24, r24
    1ca6:	99 1f       	adc	r25, r25
    1ca8:	6a 95       	dec	r22
    1caa:	e2 f7       	brpl	.-8      	; 0x1ca4 <DIO_voidSetPinVal+0x38>
    1cac:	82 2b       	or	r24, r18
    1cae:	88 bb       	out	0x18, r24	; 24
    1cb0:	08 95       	ret
    1cb2:	25 b3       	in	r18, 0x15	; 21
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	90 e0       	ldi	r25, 0x00	; 0
    1cb8:	02 c0       	rjmp	.+4      	; 0x1cbe <DIO_voidSetPinVal+0x52>
    1cba:	88 0f       	add	r24, r24
    1cbc:	99 1f       	adc	r25, r25
    1cbe:	6a 95       	dec	r22
    1cc0:	e2 f7       	brpl	.-8      	; 0x1cba <DIO_voidSetPinVal+0x4e>
    1cc2:	82 2b       	or	r24, r18
    1cc4:	85 bb       	out	0x15, r24	; 21
    1cc6:	08 95       	ret
    1cc8:	22 b3       	in	r18, 0x12	; 18
    1cca:	81 e0       	ldi	r24, 0x01	; 1
    1ccc:	90 e0       	ldi	r25, 0x00	; 0
    1cce:	02 c0       	rjmp	.+4      	; 0x1cd4 <DIO_voidSetPinVal+0x68>
    1cd0:	88 0f       	add	r24, r24
    1cd2:	99 1f       	adc	r25, r25
    1cd4:	6a 95       	dec	r22
    1cd6:	e2 f7       	brpl	.-8      	; 0x1cd0 <DIO_voidSetPinVal+0x64>
    1cd8:	82 2b       	or	r24, r18
    1cda:	82 bb       	out	0x12, r24	; 18
    1cdc:	08 95       	ret
    1cde:	41 11       	cpse	r20, r1
    1ce0:	37 c0       	rjmp	.+110    	; 0x1d50 <DIO_voidSetPinVal+0xe4>
    1ce2:	81 30       	cpi	r24, 0x01	; 1
    1ce4:	91 f0       	breq	.+36     	; 0x1d0a <DIO_voidSetPinVal+0x9e>
    1ce6:	28 f0       	brcs	.+10     	; 0x1cf2 <DIO_voidSetPinVal+0x86>
    1ce8:	82 30       	cpi	r24, 0x02	; 2
    1cea:	d9 f0       	breq	.+54     	; 0x1d22 <DIO_voidSetPinVal+0xb6>
    1cec:	83 30       	cpi	r24, 0x03	; 3
    1cee:	29 f1       	breq	.+74     	; 0x1d3a <DIO_voidSetPinVal+0xce>
    1cf0:	08 95       	ret
    1cf2:	2b b3       	in	r18, 0x1b	; 27
    1cf4:	81 e0       	ldi	r24, 0x01	; 1
    1cf6:	90 e0       	ldi	r25, 0x00	; 0
    1cf8:	02 c0       	rjmp	.+4      	; 0x1cfe <DIO_voidSetPinVal+0x92>
    1cfa:	88 0f       	add	r24, r24
    1cfc:	99 1f       	adc	r25, r25
    1cfe:	6a 95       	dec	r22
    1d00:	e2 f7       	brpl	.-8      	; 0x1cfa <DIO_voidSetPinVal+0x8e>
    1d02:	80 95       	com	r24
    1d04:	82 23       	and	r24, r18
    1d06:	8b bb       	out	0x1b, r24	; 27
    1d08:	08 95       	ret
    1d0a:	28 b3       	in	r18, 0x18	; 24
    1d0c:	81 e0       	ldi	r24, 0x01	; 1
    1d0e:	90 e0       	ldi	r25, 0x00	; 0
    1d10:	02 c0       	rjmp	.+4      	; 0x1d16 <DIO_voidSetPinVal+0xaa>
    1d12:	88 0f       	add	r24, r24
    1d14:	99 1f       	adc	r25, r25
    1d16:	6a 95       	dec	r22
    1d18:	e2 f7       	brpl	.-8      	; 0x1d12 <DIO_voidSetPinVal+0xa6>
    1d1a:	80 95       	com	r24
    1d1c:	82 23       	and	r24, r18
    1d1e:	88 bb       	out	0x18, r24	; 24
    1d20:	08 95       	ret
    1d22:	25 b3       	in	r18, 0x15	; 21
    1d24:	81 e0       	ldi	r24, 0x01	; 1
    1d26:	90 e0       	ldi	r25, 0x00	; 0
    1d28:	02 c0       	rjmp	.+4      	; 0x1d2e <DIO_voidSetPinVal+0xc2>
    1d2a:	88 0f       	add	r24, r24
    1d2c:	99 1f       	adc	r25, r25
    1d2e:	6a 95       	dec	r22
    1d30:	e2 f7       	brpl	.-8      	; 0x1d2a <DIO_voidSetPinVal+0xbe>
    1d32:	80 95       	com	r24
    1d34:	82 23       	and	r24, r18
    1d36:	85 bb       	out	0x15, r24	; 21
    1d38:	08 95       	ret
    1d3a:	22 b3       	in	r18, 0x12	; 18
    1d3c:	81 e0       	ldi	r24, 0x01	; 1
    1d3e:	90 e0       	ldi	r25, 0x00	; 0
    1d40:	02 c0       	rjmp	.+4      	; 0x1d46 <DIO_voidSetPinVal+0xda>
    1d42:	88 0f       	add	r24, r24
    1d44:	99 1f       	adc	r25, r25
    1d46:	6a 95       	dec	r22
    1d48:	e2 f7       	brpl	.-8      	; 0x1d42 <DIO_voidSetPinVal+0xd6>
    1d4a:	80 95       	com	r24
    1d4c:	82 23       	and	r24, r18
    1d4e:	82 bb       	out	0x12, r24	; 18
    1d50:	08 95       	ret

00001d52 <DIO_voidSetPortDir>:


void DIO_voidSetPortDir(u8 copy_u8port, u8 copy_u8dir){
	
	switch(copy_u8port){
    1d52:	81 30       	cpi	r24, 0x01	; 1
    1d54:	41 f0       	breq	.+16     	; 0x1d66 <DIO_voidSetPortDir+0x14>
    1d56:	28 f0       	brcs	.+10     	; 0x1d62 <DIO_voidSetPortDir+0x10>
    1d58:	82 30       	cpi	r24, 0x02	; 2
    1d5a:	39 f0       	breq	.+14     	; 0x1d6a <DIO_voidSetPortDir+0x18>
    1d5c:	83 30       	cpi	r24, 0x03	; 3
    1d5e:	39 f0       	breq	.+14     	; 0x1d6e <DIO_voidSetPortDir+0x1c>
    1d60:	08 95       	ret
		
		case DIO_PORTA: DDRA_REG=copy_u8dir ;break ; 
    1d62:	6a bb       	out	0x1a, r22	; 26
    1d64:	08 95       	ret
		case DIO_PORTB: DDRB_REG=copy_u8dir ;break ;
    1d66:	67 bb       	out	0x17, r22	; 23
    1d68:	08 95       	ret
		case DIO_PORTC: DDRC_REG=copy_u8dir ;break ;
    1d6a:	64 bb       	out	0x14, r22	; 20
    1d6c:	08 95       	ret
		case DIO_PORTD: DDRD_REG=copy_u8dir ;break ;
    1d6e:	61 bb       	out	0x11, r22	; 17
    1d70:	08 95       	ret

00001d72 <TIMER0_voidFastPWM>:
void TIMER0_voidSetCallBack(void(*ptr)(void), u8 copy_u8mode){
	
	switch(copy_u8mode){
		
		case OV_MODE : TIM0_PTR[0]=ptr ; break;
		case CTC_MODE : TIM0_PTR[1]=ptr; break; 
    1d72:	93 b7       	in	r25, 0x33	; 51
    1d74:	98 60       	ori	r25, 0x08	; 8
    1d76:	93 bf       	out	0x33, r25	; 51
    1d78:	93 b7       	in	r25, 0x33	; 51
    1d7a:	90 64       	ori	r25, 0x40	; 64
    1d7c:	93 bf       	out	0x33, r25	; 51
    1d7e:	93 b7       	in	r25, 0x33	; 51
    1d80:	90 62       	ori	r25, 0x20	; 32
    1d82:	93 bf       	out	0x33, r25	; 51
    1d84:	93 b7       	in	r25, 0x33	; 51
    1d86:	9f 7e       	andi	r25, 0xEF	; 239
    1d88:	93 bf       	out	0x33, r25	; 51
    1d8a:	93 b7       	in	r25, 0x33	; 51
    1d8c:	98 7f       	andi	r25, 0xF8	; 248
    1d8e:	93 bf       	out	0x33, r25	; 51
    1d90:	93 b7       	in	r25, 0x33	; 51
    1d92:	93 60       	ori	r25, 0x03	; 3
    1d94:	93 bf       	out	0x33, r25	; 51
    1d96:	68 2f       	mov	r22, r24
    1d98:	70 e0       	ldi	r23, 0x00	; 0
    1d9a:	80 e0       	ldi	r24, 0x00	; 0
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
    1d9e:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <__floatsisf>
    1da2:	2a e0       	ldi	r18, 0x0A	; 10
    1da4:	37 ed       	ldi	r19, 0xD7	; 215
    1da6:	43 e2       	ldi	r20, 0x23	; 35
    1da8:	50 e4       	ldi	r21, 0x40	; 64
    1daa:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <__mulsf3>
    1dae:	0e 94 11 0f 	call	0x1e22	; 0x1e22 <__fixunssfsi>
    1db2:	6c bf       	out	0x3c, r22	; 60
    1db4:	08 95       	ret

00001db6 <__vector_10>:


*/

void __vector_10(void)__attribute__((signal)) ;
void __vector_10(void){
    1db6:	1f 92       	push	r1
    1db8:	0f 92       	push	r0
    1dba:	0f b6       	in	r0, 0x3f	; 63
    1dbc:	0f 92       	push	r0
    1dbe:	11 24       	eor	r1, r1
    1dc0:	2f 93       	push	r18
    1dc2:	3f 93       	push	r19
    1dc4:	4f 93       	push	r20
    1dc6:	5f 93       	push	r21
    1dc8:	6f 93       	push	r22
    1dca:	7f 93       	push	r23
    1dcc:	8f 93       	push	r24
    1dce:	9f 93       	push	r25
    1dd0:	af 93       	push	r26
    1dd2:	bf 93       	push	r27
    1dd4:	ef 93       	push	r30
    1dd6:	ff 93       	push	r31
	

TIM0_PTR[1]() ;
    1dd8:	e0 91 9a 05 	lds	r30, 0x059A	; 0x80059a <TIM0_PTR+0x2>
    1ddc:	f0 91 9b 05 	lds	r31, 0x059B	; 0x80059b <TIM0_PTR+0x3>
    1de0:	09 95       	icall

    1de2:	ff 91       	pop	r31
    1de4:	ef 91       	pop	r30
    1de6:	bf 91       	pop	r27
    1de8:	af 91       	pop	r26
    1dea:	9f 91       	pop	r25
    1dec:	8f 91       	pop	r24
    1dee:	7f 91       	pop	r23
    1df0:	6f 91       	pop	r22
    1df2:	5f 91       	pop	r21
    1df4:	4f 91       	pop	r20
    1df6:	3f 91       	pop	r19
    1df8:	2f 91       	pop	r18
    1dfa:	0f 90       	pop	r0
    1dfc:	0f be       	out	0x3f, r0	; 63
    1dfe:	0f 90       	pop	r0
    1e00:	1f 90       	pop	r1
    1e02:	18 95       	reti

00001e04 <UART_voidInit>:
	/* SET DATA */
	UDR_REG=copy_u8data ; 
	while(GET_BIT(UCSRA_REG,5)==0) ; 
	
	
}
    1e04:	86 e8       	ldi	r24, 0x86	; 134
    1e06:	80 bd       	out	0x20, r24	; 32
    1e08:	87 e6       	ldi	r24, 0x67	; 103
    1e0a:	89 b9       	out	0x09, r24	; 9
    1e0c:	8a b1       	in	r24, 0x0a	; 10
    1e0e:	88 60       	ori	r24, 0x08	; 8
    1e10:	8a b9       	out	0x0a, r24	; 10
    1e12:	8a b1       	in	r24, 0x0a	; 10
    1e14:	80 61       	ori	r24, 0x10	; 16
    1e16:	8a b9       	out	0x0a, r24	; 10
    1e18:	08 95       	ret

00001e1a <UART_u8RX>:
u8 UART_u8RX(void) {
	
	while(GET_BIT(UCSRA_REG,7)==0) ; 
    1e1a:	5f 9b       	sbis	0x0b, 7	; 11
    1e1c:	fe cf       	rjmp	.-4      	; 0x1e1a <UART_u8RX>
	
	return UDR_REG ;  // RETURN VALUE 
    1e1e:	8c b1       	in	r24, 0x0c	; 12
    1e20:	08 95       	ret

00001e22 <__fixunssfsi>:
    1e22:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <__fp_splitA>
    1e26:	88 f0       	brcs	.+34     	; 0x1e4a <__fixunssfsi+0x28>
    1e28:	9f 57       	subi	r25, 0x7F	; 127
    1e2a:	98 f0       	brcs	.+38     	; 0x1e52 <__fixunssfsi+0x30>
    1e2c:	b9 2f       	mov	r27, r25
    1e2e:	99 27       	eor	r25, r25
    1e30:	b7 51       	subi	r27, 0x17	; 23
    1e32:	b0 f0       	brcs	.+44     	; 0x1e60 <__fixunssfsi+0x3e>
    1e34:	e1 f0       	breq	.+56     	; 0x1e6e <__fixunssfsi+0x4c>
    1e36:	66 0f       	add	r22, r22
    1e38:	77 1f       	adc	r23, r23
    1e3a:	88 1f       	adc	r24, r24
    1e3c:	99 1f       	adc	r25, r25
    1e3e:	1a f0       	brmi	.+6      	; 0x1e46 <__fixunssfsi+0x24>
    1e40:	ba 95       	dec	r27
    1e42:	c9 f7       	brne	.-14     	; 0x1e36 <__fixunssfsi+0x14>
    1e44:	14 c0       	rjmp	.+40     	; 0x1e6e <__fixunssfsi+0x4c>
    1e46:	b1 30       	cpi	r27, 0x01	; 1
    1e48:	91 f0       	breq	.+36     	; 0x1e6e <__fixunssfsi+0x4c>
    1e4a:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <__fp_zero>
    1e4e:	b1 e0       	ldi	r27, 0x01	; 1
    1e50:	08 95       	ret
    1e52:	0c 94 c7 0f 	jmp	0x1f8e	; 0x1f8e <__fp_zero>
    1e56:	67 2f       	mov	r22, r23
    1e58:	78 2f       	mov	r23, r24
    1e5a:	88 27       	eor	r24, r24
    1e5c:	b8 5f       	subi	r27, 0xF8	; 248
    1e5e:	39 f0       	breq	.+14     	; 0x1e6e <__fixunssfsi+0x4c>
    1e60:	b9 3f       	cpi	r27, 0xF9	; 249
    1e62:	cc f3       	brlt	.-14     	; 0x1e56 <__fixunssfsi+0x34>
    1e64:	86 95       	lsr	r24
    1e66:	77 95       	ror	r23
    1e68:	67 95       	ror	r22
    1e6a:	b3 95       	inc	r27
    1e6c:	d9 f7       	brne	.-10     	; 0x1e64 <__fixunssfsi+0x42>
    1e6e:	3e f4       	brtc	.+14     	; 0x1e7e <__fixunssfsi+0x5c>
    1e70:	90 95       	com	r25
    1e72:	80 95       	com	r24
    1e74:	70 95       	com	r23
    1e76:	61 95       	neg	r22
    1e78:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7a:	8f 4f       	sbci	r24, 0xFF	; 255
    1e7c:	9f 4f       	sbci	r25, 0xFF	; 255
    1e7e:	08 95       	ret

00001e80 <__floatunsisf>:
    1e80:	e8 94       	clt
    1e82:	09 c0       	rjmp	.+18     	; 0x1e96 <__floatsisf+0x12>

00001e84 <__floatsisf>:
    1e84:	97 fb       	bst	r25, 7
    1e86:	3e f4       	brtc	.+14     	; 0x1e96 <__floatsisf+0x12>
    1e88:	90 95       	com	r25
    1e8a:	80 95       	com	r24
    1e8c:	70 95       	com	r23
    1e8e:	61 95       	neg	r22
    1e90:	7f 4f       	sbci	r23, 0xFF	; 255
    1e92:	8f 4f       	sbci	r24, 0xFF	; 255
    1e94:	9f 4f       	sbci	r25, 0xFF	; 255
    1e96:	99 23       	and	r25, r25
    1e98:	a9 f0       	breq	.+42     	; 0x1ec4 <__floatsisf+0x40>
    1e9a:	f9 2f       	mov	r31, r25
    1e9c:	96 e9       	ldi	r25, 0x96	; 150
    1e9e:	bb 27       	eor	r27, r27
    1ea0:	93 95       	inc	r25
    1ea2:	f6 95       	lsr	r31
    1ea4:	87 95       	ror	r24
    1ea6:	77 95       	ror	r23
    1ea8:	67 95       	ror	r22
    1eaa:	b7 95       	ror	r27
    1eac:	f1 11       	cpse	r31, r1
    1eae:	f8 cf       	rjmp	.-16     	; 0x1ea0 <__floatsisf+0x1c>
    1eb0:	fa f4       	brpl	.+62     	; 0x1ef0 <__floatsisf+0x6c>
    1eb2:	bb 0f       	add	r27, r27
    1eb4:	11 f4       	brne	.+4      	; 0x1eba <__floatsisf+0x36>
    1eb6:	60 ff       	sbrs	r22, 0
    1eb8:	1b c0       	rjmp	.+54     	; 0x1ef0 <__floatsisf+0x6c>
    1eba:	6f 5f       	subi	r22, 0xFF	; 255
    1ebc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ebe:	8f 4f       	sbci	r24, 0xFF	; 255
    1ec0:	9f 4f       	sbci	r25, 0xFF	; 255
    1ec2:	16 c0       	rjmp	.+44     	; 0x1ef0 <__floatsisf+0x6c>
    1ec4:	88 23       	and	r24, r24
    1ec6:	11 f0       	breq	.+4      	; 0x1ecc <__floatsisf+0x48>
    1ec8:	96 e9       	ldi	r25, 0x96	; 150
    1eca:	11 c0       	rjmp	.+34     	; 0x1eee <__floatsisf+0x6a>
    1ecc:	77 23       	and	r23, r23
    1ece:	21 f0       	breq	.+8      	; 0x1ed8 <__floatsisf+0x54>
    1ed0:	9e e8       	ldi	r25, 0x8E	; 142
    1ed2:	87 2f       	mov	r24, r23
    1ed4:	76 2f       	mov	r23, r22
    1ed6:	05 c0       	rjmp	.+10     	; 0x1ee2 <__floatsisf+0x5e>
    1ed8:	66 23       	and	r22, r22
    1eda:	71 f0       	breq	.+28     	; 0x1ef8 <__floatsisf+0x74>
    1edc:	96 e8       	ldi	r25, 0x86	; 134
    1ede:	86 2f       	mov	r24, r22
    1ee0:	70 e0       	ldi	r23, 0x00	; 0
    1ee2:	60 e0       	ldi	r22, 0x00	; 0
    1ee4:	2a f0       	brmi	.+10     	; 0x1ef0 <__floatsisf+0x6c>
    1ee6:	9a 95       	dec	r25
    1ee8:	66 0f       	add	r22, r22
    1eea:	77 1f       	adc	r23, r23
    1eec:	88 1f       	adc	r24, r24
    1eee:	da f7       	brpl	.-10     	; 0x1ee6 <__floatsisf+0x62>
    1ef0:	88 0f       	add	r24, r24
    1ef2:	96 95       	lsr	r25
    1ef4:	87 95       	ror	r24
    1ef6:	97 f9       	bld	r25, 7
    1ef8:	08 95       	ret

00001efa <__fp_inf>:
    1efa:	97 f9       	bld	r25, 7
    1efc:	9f 67       	ori	r25, 0x7F	; 127
    1efe:	80 e8       	ldi	r24, 0x80	; 128
    1f00:	70 e0       	ldi	r23, 0x00	; 0
    1f02:	60 e0       	ldi	r22, 0x00	; 0
    1f04:	08 95       	ret

00001f06 <__fp_nan>:
    1f06:	9f ef       	ldi	r25, 0xFF	; 255
    1f08:	80 ec       	ldi	r24, 0xC0	; 192
    1f0a:	08 95       	ret

00001f0c <__fp_pscA>:
    1f0c:	00 24       	eor	r0, r0
    1f0e:	0a 94       	dec	r0
    1f10:	16 16       	cp	r1, r22
    1f12:	17 06       	cpc	r1, r23
    1f14:	18 06       	cpc	r1, r24
    1f16:	09 06       	cpc	r0, r25
    1f18:	08 95       	ret

00001f1a <__fp_pscB>:
    1f1a:	00 24       	eor	r0, r0
    1f1c:	0a 94       	dec	r0
    1f1e:	12 16       	cp	r1, r18
    1f20:	13 06       	cpc	r1, r19
    1f22:	14 06       	cpc	r1, r20
    1f24:	05 06       	cpc	r0, r21
    1f26:	08 95       	ret

00001f28 <__fp_round>:
    1f28:	09 2e       	mov	r0, r25
    1f2a:	03 94       	inc	r0
    1f2c:	00 0c       	add	r0, r0
    1f2e:	11 f4       	brne	.+4      	; 0x1f34 <__fp_round+0xc>
    1f30:	88 23       	and	r24, r24
    1f32:	52 f0       	brmi	.+20     	; 0x1f48 <__fp_round+0x20>
    1f34:	bb 0f       	add	r27, r27
    1f36:	40 f4       	brcc	.+16     	; 0x1f48 <__fp_round+0x20>
    1f38:	bf 2b       	or	r27, r31
    1f3a:	11 f4       	brne	.+4      	; 0x1f40 <__fp_round+0x18>
    1f3c:	60 ff       	sbrs	r22, 0
    1f3e:	04 c0       	rjmp	.+8      	; 0x1f48 <__fp_round+0x20>
    1f40:	6f 5f       	subi	r22, 0xFF	; 255
    1f42:	7f 4f       	sbci	r23, 0xFF	; 255
    1f44:	8f 4f       	sbci	r24, 0xFF	; 255
    1f46:	9f 4f       	sbci	r25, 0xFF	; 255
    1f48:	08 95       	ret

00001f4a <__fp_split3>:
    1f4a:	57 fd       	sbrc	r21, 7
    1f4c:	90 58       	subi	r25, 0x80	; 128
    1f4e:	44 0f       	add	r20, r20
    1f50:	55 1f       	adc	r21, r21
    1f52:	59 f0       	breq	.+22     	; 0x1f6a <__fp_splitA+0x10>
    1f54:	5f 3f       	cpi	r21, 0xFF	; 255
    1f56:	71 f0       	breq	.+28     	; 0x1f74 <__fp_splitA+0x1a>
    1f58:	47 95       	ror	r20

00001f5a <__fp_splitA>:
    1f5a:	88 0f       	add	r24, r24
    1f5c:	97 fb       	bst	r25, 7
    1f5e:	99 1f       	adc	r25, r25
    1f60:	61 f0       	breq	.+24     	; 0x1f7a <__fp_splitA+0x20>
    1f62:	9f 3f       	cpi	r25, 0xFF	; 255
    1f64:	79 f0       	breq	.+30     	; 0x1f84 <__fp_splitA+0x2a>
    1f66:	87 95       	ror	r24
    1f68:	08 95       	ret
    1f6a:	12 16       	cp	r1, r18
    1f6c:	13 06       	cpc	r1, r19
    1f6e:	14 06       	cpc	r1, r20
    1f70:	55 1f       	adc	r21, r21
    1f72:	f2 cf       	rjmp	.-28     	; 0x1f58 <__fp_split3+0xe>
    1f74:	46 95       	lsr	r20
    1f76:	f1 df       	rcall	.-30     	; 0x1f5a <__fp_splitA>
    1f78:	08 c0       	rjmp	.+16     	; 0x1f8a <__fp_splitA+0x30>
    1f7a:	16 16       	cp	r1, r22
    1f7c:	17 06       	cpc	r1, r23
    1f7e:	18 06       	cpc	r1, r24
    1f80:	99 1f       	adc	r25, r25
    1f82:	f1 cf       	rjmp	.-30     	; 0x1f66 <__fp_splitA+0xc>
    1f84:	86 95       	lsr	r24
    1f86:	71 05       	cpc	r23, r1
    1f88:	61 05       	cpc	r22, r1
    1f8a:	08 94       	sec
    1f8c:	08 95       	ret

00001f8e <__fp_zero>:
    1f8e:	e8 94       	clt

00001f90 <__fp_szero>:
    1f90:	bb 27       	eor	r27, r27
    1f92:	66 27       	eor	r22, r22
    1f94:	77 27       	eor	r23, r23
    1f96:	cb 01       	movw	r24, r22
    1f98:	97 f9       	bld	r25, 7
    1f9a:	08 95       	ret

00001f9c <__mulsf3>:
    1f9c:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <__mulsf3x>
    1fa0:	0c 94 94 0f 	jmp	0x1f28	; 0x1f28 <__fp_round>
    1fa4:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <__fp_pscA>
    1fa8:	38 f0       	brcs	.+14     	; 0x1fb8 <__mulsf3+0x1c>
    1faa:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <__fp_pscB>
    1fae:	20 f0       	brcs	.+8      	; 0x1fb8 <__mulsf3+0x1c>
    1fb0:	95 23       	and	r25, r21
    1fb2:	11 f0       	breq	.+4      	; 0x1fb8 <__mulsf3+0x1c>
    1fb4:	0c 94 7d 0f 	jmp	0x1efa	; 0x1efa <__fp_inf>
    1fb8:	0c 94 83 0f 	jmp	0x1f06	; 0x1f06 <__fp_nan>
    1fbc:	11 24       	eor	r1, r1
    1fbe:	0c 94 c8 0f 	jmp	0x1f90	; 0x1f90 <__fp_szero>

00001fc2 <__mulsf3x>:
    1fc2:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <__fp_split3>
    1fc6:	70 f3       	brcs	.-36     	; 0x1fa4 <__mulsf3+0x8>

00001fc8 <__mulsf3_pse>:
    1fc8:	95 9f       	mul	r25, r21
    1fca:	c1 f3       	breq	.-16     	; 0x1fbc <__mulsf3+0x20>
    1fcc:	95 0f       	add	r25, r21
    1fce:	50 e0       	ldi	r21, 0x00	; 0
    1fd0:	55 1f       	adc	r21, r21
    1fd2:	62 9f       	mul	r22, r18
    1fd4:	f0 01       	movw	r30, r0
    1fd6:	72 9f       	mul	r23, r18
    1fd8:	bb 27       	eor	r27, r27
    1fda:	f0 0d       	add	r31, r0
    1fdc:	b1 1d       	adc	r27, r1
    1fde:	63 9f       	mul	r22, r19
    1fe0:	aa 27       	eor	r26, r26
    1fe2:	f0 0d       	add	r31, r0
    1fe4:	b1 1d       	adc	r27, r1
    1fe6:	aa 1f       	adc	r26, r26
    1fe8:	64 9f       	mul	r22, r20
    1fea:	66 27       	eor	r22, r22
    1fec:	b0 0d       	add	r27, r0
    1fee:	a1 1d       	adc	r26, r1
    1ff0:	66 1f       	adc	r22, r22
    1ff2:	82 9f       	mul	r24, r18
    1ff4:	22 27       	eor	r18, r18
    1ff6:	b0 0d       	add	r27, r0
    1ff8:	a1 1d       	adc	r26, r1
    1ffa:	62 1f       	adc	r22, r18
    1ffc:	73 9f       	mul	r23, r19
    1ffe:	b0 0d       	add	r27, r0
    2000:	a1 1d       	adc	r26, r1
    2002:	62 1f       	adc	r22, r18
    2004:	83 9f       	mul	r24, r19
    2006:	a0 0d       	add	r26, r0
    2008:	61 1d       	adc	r22, r1
    200a:	22 1f       	adc	r18, r18
    200c:	74 9f       	mul	r23, r20
    200e:	33 27       	eor	r19, r19
    2010:	a0 0d       	add	r26, r0
    2012:	61 1d       	adc	r22, r1
    2014:	23 1f       	adc	r18, r19
    2016:	84 9f       	mul	r24, r20
    2018:	60 0d       	add	r22, r0
    201a:	21 1d       	adc	r18, r1
    201c:	82 2f       	mov	r24, r18
    201e:	76 2f       	mov	r23, r22
    2020:	6a 2f       	mov	r22, r26
    2022:	11 24       	eor	r1, r1
    2024:	9f 57       	subi	r25, 0x7F	; 127
    2026:	50 40       	sbci	r21, 0x00	; 0
    2028:	9a f0       	brmi	.+38     	; 0x2050 <__mulsf3_pse+0x88>
    202a:	f1 f0       	breq	.+60     	; 0x2068 <__mulsf3_pse+0xa0>
    202c:	88 23       	and	r24, r24
    202e:	4a f0       	brmi	.+18     	; 0x2042 <__mulsf3_pse+0x7a>
    2030:	ee 0f       	add	r30, r30
    2032:	ff 1f       	adc	r31, r31
    2034:	bb 1f       	adc	r27, r27
    2036:	66 1f       	adc	r22, r22
    2038:	77 1f       	adc	r23, r23
    203a:	88 1f       	adc	r24, r24
    203c:	91 50       	subi	r25, 0x01	; 1
    203e:	50 40       	sbci	r21, 0x00	; 0
    2040:	a9 f7       	brne	.-22     	; 0x202c <__mulsf3_pse+0x64>
    2042:	9e 3f       	cpi	r25, 0xFE	; 254
    2044:	51 05       	cpc	r21, r1
    2046:	80 f0       	brcs	.+32     	; 0x2068 <__mulsf3_pse+0xa0>
    2048:	0c 94 7d 0f 	jmp	0x1efa	; 0x1efa <__fp_inf>
    204c:	0c 94 c8 0f 	jmp	0x1f90	; 0x1f90 <__fp_szero>
    2050:	5f 3f       	cpi	r21, 0xFF	; 255
    2052:	e4 f3       	brlt	.-8      	; 0x204c <__mulsf3_pse+0x84>
    2054:	98 3e       	cpi	r25, 0xE8	; 232
    2056:	d4 f3       	brlt	.-12     	; 0x204c <__mulsf3_pse+0x84>
    2058:	86 95       	lsr	r24
    205a:	77 95       	ror	r23
    205c:	67 95       	ror	r22
    205e:	b7 95       	ror	r27
    2060:	f7 95       	ror	r31
    2062:	e7 95       	ror	r30
    2064:	9f 5f       	subi	r25, 0xFF	; 255
    2066:	c1 f7       	brne	.-16     	; 0x2058 <__mulsf3_pse+0x90>
    2068:	fe 2b       	or	r31, r30
    206a:	88 0f       	add	r24, r24
    206c:	91 1d       	adc	r25, r1
    206e:	96 95       	lsr	r25
    2070:	87 95       	ror	r24
    2072:	97 f9       	bld	r25, 7
    2074:	08 95       	ret

00002076 <__udivmodsi4>:
    2076:	a1 e2       	ldi	r26, 0x21	; 33
    2078:	1a 2e       	mov	r1, r26
    207a:	aa 1b       	sub	r26, r26
    207c:	bb 1b       	sub	r27, r27
    207e:	fd 01       	movw	r30, r26
    2080:	0d c0       	rjmp	.+26     	; 0x209c <__udivmodsi4_ep>

00002082 <__udivmodsi4_loop>:
    2082:	aa 1f       	adc	r26, r26
    2084:	bb 1f       	adc	r27, r27
    2086:	ee 1f       	adc	r30, r30
    2088:	ff 1f       	adc	r31, r31
    208a:	a2 17       	cp	r26, r18
    208c:	b3 07       	cpc	r27, r19
    208e:	e4 07       	cpc	r30, r20
    2090:	f5 07       	cpc	r31, r21
    2092:	20 f0       	brcs	.+8      	; 0x209c <__udivmodsi4_ep>
    2094:	a2 1b       	sub	r26, r18
    2096:	b3 0b       	sbc	r27, r19
    2098:	e4 0b       	sbc	r30, r20
    209a:	f5 0b       	sbc	r31, r21

0000209c <__udivmodsi4_ep>:
    209c:	66 1f       	adc	r22, r22
    209e:	77 1f       	adc	r23, r23
    20a0:	88 1f       	adc	r24, r24
    20a2:	99 1f       	adc	r25, r25
    20a4:	1a 94       	dec	r1
    20a6:	69 f7       	brne	.-38     	; 0x2082 <__udivmodsi4_loop>
    20a8:	60 95       	com	r22
    20aa:	70 95       	com	r23
    20ac:	80 95       	com	r24
    20ae:	90 95       	com	r25
    20b0:	9b 01       	movw	r18, r22
    20b2:	ac 01       	movw	r20, r24
    20b4:	bd 01       	movw	r22, r26
    20b6:	cf 01       	movw	r24, r30
    20b8:	08 95       	ret

000020ba <memcpy>:
    20ba:	fb 01       	movw	r30, r22
    20bc:	dc 01       	movw	r26, r24
    20be:	02 c0       	rjmp	.+4      	; 0x20c4 <memcpy+0xa>
    20c0:	01 90       	ld	r0, Z+
    20c2:	0d 92       	st	X+, r0
    20c4:	41 50       	subi	r20, 0x01	; 1
    20c6:	50 40       	sbci	r21, 0x00	; 0
    20c8:	d8 f7       	brcc	.-10     	; 0x20c0 <memcpy+0x6>
    20ca:	08 95       	ret

000020cc <_exit>:
    20cc:	f8 94       	cli

000020ce <__stop_program>:
    20ce:	ff cf       	rjmp	.-2      	; 0x20ce <__stop_program>
